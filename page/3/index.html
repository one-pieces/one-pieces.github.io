<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 3 | One Pieces</title>

  
  <meta name="author" content="Xiaolong Lin">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="One Pieces"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="One Pieces" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">One Pieces</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/08/14-javascript中的事件绑定、事件监听和事件委托/"><span>14.JavaScript中的事件绑定、事件监听和事件委托</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/08/14-javascript中的事件绑定、事件监听和事件委托/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-08T11:23:55.000Z">
          2018-03-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>【转自】<a href="https://www.cnblogs.com/Tacklingpioneer/p/6433959.html" target="_blank" rel="noopener">https://www.cnblogs.com/Tacklingpioneer/p/6433959.html</a></p>
<p>在JavaScript的学习中，我们经常会遇到JavaScript的事件机制，例如，事件绑定、事件监听、事件委托（事件代理）等。这些名词是什么意思呢，有什么作用？</p>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>要想让JavaScript对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同操作对应不同的名称。</p>
<p>在JavaScript中，有三种常用的绑定事件的方法：</p>
<ul>
<li>在 DOM 元素中直接绑定</li>
<li>在JavaScript代码中绑定</li>
<li>绑定事件监听函数</li>
</ul>
<h3 id="在-DOM-中直接绑定事件"><a href="#在-DOM-中直接绑定事件" class="headerlink" title="在 DOM 中直接绑定事件"></a>在 DOM 中直接绑定事件</h3><p>我们可以在 DOM 元素上绑定 onclick、onmouseover、onmouseout、onmousedown、onmouseup、onkeydown、onkeypress等。更多事件类型请查看<a href="http://www.runoob.com/jsref/dom-obj-event.html" target="_blank" rel="noopener">DOM事件</a>。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">onclick</span>=<span class="string">"hello()"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  function hello() &#123;</span></span><br><span class="line"><span class="undefined">    alert("hello world!");</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="在JavaScript代码中绑定事件"><a href="#在JavaScript代码中绑定事件" class="headerlink" title="在JavaScript代码中绑定事件"></a>在JavaScript代码中绑定事件</h3><p>在JavaScript代码中（即 script 标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  document.getElementById("btn").onclick = function() &#123;</span></span><br><span class="line"><span class="undefined">    alert("hello world!");</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="使用事件监听绑定事件"><a href="#使用事件监听绑定事件" class="headerlink" title="使用事件监听绑定事件"></a>使用事件监听绑定事件</h3><p>绑定事件的另一种方法是用 addEventListener() 或 attachEvent() 来绑定事件监听函数。下面详细介绍，事件监听。</p>
<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>关于事件监听，W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。</p>
<p>起初NetScape制定了JavaScript的一套事件驱动机制（即事件捕获）。随机IE也推出了自己的一套事件驱动机制（即事件冒泡）。最后W3C规范了两种事件机制，分为捕获阶段、目标阶段、冒泡阶段。IE8以前IE一直坚持自己的事件机制（前端人员一直头疼的兼容问题），IE9以后IE也支持了W3C规范。</p>
<h3 id="W3C规范"><a href="#W3C规范" class="headerlink" title="W3C规范"></a>W3C规范</h3><p>语法：  </p>
<p>element.addEventListener(event, function, useCapture)</p>
<ul>
<li>event：（必需）事件名，支持所有<a href="http://www.runoob.com/jsref/dom-obj-event.html" target="_blank" rel="noopener">DOM事件</a></li>
<li>function：（必需）指定要事件触发时执行的函数</li>
<li>useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。</li>
</ul>
<p>注：IE8以下不支持。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">id</span>=<span class="string">"btn1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  document.getElementById("btn1").addEventListener("click", hello);</span></span><br><span class="line"><span class="undefined">  function hello() &#123;</span></span><br><span class="line"><span class="undefined">    alert("hello world!");</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="IE标准"><a href="#IE标准" class="headerlink" title="IE标准"></a>IE标准</h3><p>语法：</p>
<p>element.attachEvent(event, function)</p>
<ul>
<li>event：（必需）事件类型。需加”on”，例如：onclick。</li>
<li>function：（必需）指定要事件触发时执行的函数。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">id</span>=<span class="string">"btn2"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  document.getElementById("btn2").attachEvent("onclick", hello);</span></span><br><span class="line"><span class="undefined">  function hello() &#123;</span></span><br><span class="line"><span class="undefined">    alert("hello world!");</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="事件监听的优点"><a href="#事件监听的优点" class="headerlink" title="事件监听的优点"></a>事件监听的优点</h2><ol>
<li>可以绑定多个事件。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">id</span>=<span class="string">"btn3"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  var btn3 = document.getElementById("btn3");</span></span><br><span class="line"><span class="undefined">  btn3.onclick = function() &#123;</span></span><br><span class="line"><span class="undefined">    alert("hello 1"); // 不执行</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  btn3.onclick = function() &#123;</span></span><br><span class="line"><span class="undefined">    alert("hello 2"); // 执行</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>常规的事件绑定只执行最后绑定的事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">id</span>=<span class="string">"btn4"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  var btn4 = document.getElementById("btn4");</span></span><br><span class="line"><span class="undefined">  btn4.addEventListener("click", hello1);</span></span><br><span class="line"><span class="undefined">  btn4.addEventListener("click", hello2);</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">  function hello1() &#123;</span></span><br><span class="line"><span class="undefined">    alert("hello 1");</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  function hello2() &#123;</span></span><br><span class="line"><span class="undefined">    alert("hello 2");</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>两个事件都执行了。</p>
<ol start="2">
<li>可以解绑响应的事件</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">id</span>=<span class="string">"btn5"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  var btn5 = document.getElementById("btn5");</span></span><br><span class="line"><span class="undefined">  btn5.addEventListener("click", hello1); // 执行</span></span><br><span class="line"><span class="undefined">  btn5.addEventListener("click", hello2); // 不执行</span></span><br><span class="line"><span class="undefined">  btn5.removeEventListener("click", hello2);</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">  function hello1() &#123;</span></span><br><span class="line"><span class="undefined">    alert("hello 1");</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  function hello2() &#123;</span></span><br><span class="line"><span class="undefined">    alert("hello 2");</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="封装事件监听"><a href="#封装事件监听" class="headerlink" title="封装事件监听"></a>封装事件监听</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">id</span>=<span class="string">"btn5"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 绑定监听事件</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/javascript/">javascript</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/07/13-leetcode刷题记录/"><span>13.leetcode刷题记录</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/07/13-leetcode刷题记录/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-07T04:18:08.000Z">
          2018-03-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="https://leetcode.com/problemset/all/" target="_blank" rel="noopener">题目（英文版）</a><br><a href="https://cn.leetcode.com/problemset/all/" target="_blank" rel="noopener">题目（中文版）</a></p>
<p><strong>2018.3.5</strong></p>
<ol>
<li><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a>(Easy)</p>
</li>
<li><p><a href="https://leetcode.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">Add Two Numbers</a>(Medium)</p>
</li>
</ol>
<p><strong>2018.3.6</strong></p>
<ol start="3">
<li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">Longest Subtring Without Repeating characters</a>(Medium)</li>
</ol>
<p><strong>2018.3.7</strong></p>
<ol start="5">
<li><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">Longest Palindromic Substring</a>(Medium)</li>
<li><a href="https://leetcode.com/problems/reverse-integer/description/" target="_blank" rel="noopener">Reverse Integer</a>(Easy)</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/算法/">算法</a><a href="/tags/面试/">面试</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/06/12.理解时间复杂度概念/"><span>理解时间复杂度概念</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/06/12.理解时间复杂度概念/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-06T09:32:39.000Z">
          2018-03-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>以下内容转自<br><a href="https://www.zhihu.com/question/21387264/answer/253704111" target="_blank" rel="noopener">算法时间复杂度的表示法O(n²)、O(n)、O(1)、O(nlogn)等是什么意思？ - 缪志威的回答 - 知乎</a></p>
<p>在数学上定义：存在常数 c, 使得当 N &gt;= c 时 T(N) &lt;= f(N)，表示为T(n) = O(f(n))。</p>
<p>我们先从头开始看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int aFunc(void) &#123;</span><br><span class="line">   printf(&quot;Hello, World!\n&quot;);      //  需要执行 1 次</span><br><span class="line">   return 0;       // 需要执行 1 次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么上面这个方法需要执行2次运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int aFunc(int n) &#123;</span><br><span class="line">   for(int i = 0; i &lt; n; i++) &#123;         // 需要执行 (n + 1) 次</span><br><span class="line">       printf(&quot;Hello, World!\n&quot;);      // 需要执行 n 次</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;       // 需要执行 1 次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法需要 (n + 1 + n + 1) = 2n + 2 次运算。</p>
<p>我们把算法需要执行的运算次数用输入大小 n 的函数表示，即 T(n)。<br>此时为了估算算法需要的运行时间和简化算法分析，我们引入时间复杂度的概念。</p>
<p><strong>数学上定义：存在常数 c，使得当 N &gt;= c 时 T(N) &lt;= f(N)，表示为 T(n) = O(f(n))。</strong></p>
<p>怎么理解呢？</p>
<p>如图：<br><img src="../images/12/1.jpg" alt="image"></p>
<p><strong>当 N &gt;= 2 的时候，f(n) = n^2 总是大于 T(n) = n + 2 的，于是我们说 f(n) 的增长速度是大于或者等于 T(n) 的，也说 f(n) 是 T(n) 的上界，可以表示为 T(n) = O(f(n))。</strong></p>
<p>因为 f(n) 的增长速度是大于或者等于 T(n) 的，即T(n) = O(f(n))，所以我们可以用 f(n) 的增长速度来度量 T(n) 的增长速度，所以我们说这个算法的时间复杂度是 O(f(n))。</p>
<p><strong>所以就有了我们现在理解的时间复杂度，记作: T(n) = O(f(n))，用来度量算法的运行时间。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。</strong></p>
<p>显然如果 T(n) = n^2，那么 T(n) = O(n^2)，T(n) = O(n^3)，T(n) = O(n^4) 都是成立的，但是因为第一个 f(n) 的增长速度与 T(n) 是最接近的，所以第一个是最好的选择，所以我们说这个算法的复杂度是 O(n^2) 。</p>
<p>可以参考<a href="https://www.jianshu.com/p/f4cca5ce055a" target="_blank" rel="noopener">十分钟从零搞定时间复杂度</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/算法/">算法</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/01/25/使用css时的坑/"><span>使用css时的坑</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/01/25/使用css时的坑/" rel="bookmark">
        <time class="entry-date published" datetime="2018-01-25T06:30:28.000Z">
          2018-01-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <ol>
<li>height：100%的问题<br>有时我们为了让元素高度占满整屏，会把元素的height设置为100%，这样貌似没问题。<br><img src="../images/shi-yong-css-shi-de-keng/height100.png" alt="image"></li>
</ol>
<p>但只是这样会有一个问题。但元素内的内容高度大于元素高度时，超过的部分的背景色就不为元素的背景色。<br><img src="../images/shi-yong-css-shi-de-keng/height100-bug.png" alt="image"></p>
<p>这是因为元素的overflow为visible(默认值)，这时元素的高度为可视部分的高度。</p>
<p>我们把overflow设置为auto，即可修复这个问题。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/css/">css</a><a href="/tags/样式/">样式</a><a href="/tags/坑/">坑</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/12/05/vue使用jsx时的坑/"><span>vue使用jsx时的坑</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/12/05/vue使用jsx时的坑/" rel="bookmark">
        <time class="entry-date published" datetime="2017-12-05T12:30:04.000Z">
          2017-12-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <ol>
<li><p>v-model<br>在jsx中无法直接使用v-model，需要借助一个插件babel-plugin-jsx-v-model</p>
</li>
<li><p><component><br>在jsx中使用动态组件标签<component>会报无法找到component组件的错<br>解决方法：<br>直接使用判断语句控制该使用哪个组件</component></component></p>
</li>
<li><p>v-if<br>v-if在jsx中是没有作用的<br>解决办法：<br>跟<compnent>一样，直接使用判断语句</compnent></p>
</li>
<li><p>使用on<br>在jsx中我们要监听一个事件，可以使用on-{eventName}或者on{EventName}的形式，如</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button on-click=&#123;<span class="keyword">this</span>.myClickListener&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.myClickListener&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>同时，我们也可以使用on来让组件获得事件监听的能力，如<br><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button &#123;...&#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: <span class="keyword">this</span>.myClickListener &#125;&#125;&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>当使用on时，只能像上面一样，用解构的写法才有效，如果像下面这样写是没有效果的。<br><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button on=&#123;&#123; <span class="attr">click</span>: <span class="keyword">this</span>.myClickListener &#125;&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>注意！on-{eventName}或on{EventName}跟on一起写时，on会无效。比如<br><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input onClick=&#123;<span class="keyword">this</span>.myClickListener&#125; &#123;...&#123; <span class="attr">on</span>: &#123; <span class="attr">input</span>: <span class="keyword">this</span>.myInputListener &#125; &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>当触发input事件时会报错。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/坑/">坑</a><a href="/tags/vue/">vue</a><a href="/tags/jsx/">jsx</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/10/12/javascript-in-one-pic/"><span>JavaScript in One Pic</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/10/12/javascript-in-one-pic/" rel="bookmark">
        <time class="entry-date published" datetime="2017-10-12T11:23:28.000Z">
          2017-10-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><img src="https://raw.githubusercontent.com/coodict/javascript-in-one-pic/master/js%20in%20one%20pic.png" alt="image"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/javascript/">javascript</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/09/09/币圈大事件/"><span>币圈大事件</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/09/09/币圈大事件/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-09T06:30:28.000Z">
          2017-09-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>2017-9-8</code><br><a href="http://www.sohu.com/a/190793469_120702?_f=index_pagerecom_3" target="_blank" rel="noopener">消息称中国虚拟货币交易所将被关闭 比特币大跌超20%</a></p>
<p><code>2017-9-5</code><br><a href="http://www.sohu.com/a/169594064_479736" target="_blank" rel="noopener">【七部委全面叫停ICO 正式定性为非法集资】</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/币圈/">币圈</a><a href="/tags/比特币/">比特币</a><a href="/tags/虚拟货币/">虚拟货币</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/09/06/【转】前端扫盲之打造一个Node命令行工具/"><span>【转】前端扫盲之打造一个Node命令行工具</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/09/06/【转】前端扫盲之打造一个Node命令行工具/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-06T06:30:28.000Z">
          2017-09-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="http://www.imooc.com/article/3384" target="_blank" rel="noopener">原文链接</a></p>
<p>Node 给前端开发带来了很大的改变，促进了前端开发的自动化，我们可以简化开发工作，然后利用各种工具包生成生产环境。如运行 <code>sass src/sass/main.scss dist/css/main.css</code> 即可编译Sass文件。在实际的开发过程中，我们可能会有自己的特定需求，那么我们得学会如何创建一个Node命令行工具。</p>
<p>命令行接口：Command Line Interface，简称CLI，是Node提供的一个用于命令行交互的工具，本质是基于Node引擎运行的。</p>
<p>在前面的文章<a href="https://www.awesomes.cn/source/9" target="_blank" rel="noopener">前端扫盲-之打造一个自动化的前端项目</a>中，给大家留了一个问题，就是如何通过执行一条命令就生成我们需要的项目结构。今天我就带着大家一步一步解答这个问题。</p>
<p>我们的初步设想是，在指定目录下执行一个命令（假设为autogo）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autogo demo</span><br></pre></td></tr></table></figure></p>
<p>就会生成一个目录名为<code>demo</code>的项目，里面包含有我们所需的基础文件结构。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>1.首先我们创建一个程序包清单（<code>package.json</code>文件）包含了该命令包的相关信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></p>
<p>然后根据提示输入对应的信息，也可以一路回车，待生成好<code>package.json</code>文件后再作修改。</p>
<p>2.创建一个用于运行命令的脚本<code>bin/autogo.js</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后我们执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node bin/autogo.js</span><br></pre></td></tr></table></figure></p>
<p>能够看到输出了<code>hello</code>，当然这不是我们想要的结果， 我们是要直接运行<code>autogo</code>命令就能输出<code>hello</code>。</p>
<p>3.告诉<code>npm</code>你的命令脚本文件是哪一个，这里我们需要给<code>package.json</code>添加一个<code>bin</code>字段：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bin"</span>: &#123;</span><br><span class="line">    <span class="attr">"autogo"</span>: <span class="string">"./bin/autogo.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们指定<code>autogo</code>命令的执行文件为<code>./bin/autogo.js</code>.</p>
<p>4.启用命令行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure></p>
<p>这里我们通过<code>npm link</code>在本地安装了这个包用于测试，然后就可以通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autogo</span><br></pre></td></tr></table></figure></p>
<p>来运行命令了。</p>
<h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><p>1.有的同学可能在执行<code>autogo</code>命令后报下面的错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: /usr/<span class="built_in">local</span>/bin/autogo: /usr/<span class="built_in">local</span>/bin/node^M: bad interpreter: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>之所以出现这个错误是因为<code>bin/autogo.js</code>文件是在windows下做的编辑，windows下默认的换行是<code>\n\r</code>，而linux下默认的换行是<code>\n</code>，所以文件后的<code>\r</code>在linux下是不会被识别的，显示成了^M。</p>
<p>要解决这个问题的办法就是改变文件的编码，这里我们需要用到<code>dos2unix</code>这个包。</p>
<p>首先安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install dos2unix</span><br></pre></td></tr></table></figure></p>
<p>然后<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dos2unix bin.autogo.js</span><br></pre></td></tr></table></figure></p>
<p>问题就解决了。</p>
<p>2.还有的同学可能会遇到下面这个报错<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>报这个错是因为<code>#! /usr/bin/env/node</code>没能识别出你的<code>node</code>的路径，需要将你的<code>node</code>安装路径（如<code>/usr/local/bin/</code>）加入到系统的PATH中。</p>
<p>其实你可以在测试环境中将这个标识换成<code>#! /usr/local/bin/node</code>（这里的<code>which node</code>找到你自己的<code>node</code>路径），再运行就没问题了。但是我们之所以用<code>#! /usr/bin/env/node</code>是因为这可以动态检测出不同用户各自的<code>node</code>路径，而不是写死的，毕竟不是所有用户的<code>node</code>命令都是在<code>/usr/local/bin/</code>下。得确保在发布之前将其改回成<code>#! /usr/bin/env/node</code>。</p>
<p>到此，一个本地的<code>npm</code>命令行工具就已经成功完成了，（可参见<a href="http://blog.npmjs.org/post/118810260230/building-a-simple-command-line-tool-with-npm" target="_blank" rel="noopener">官方文档</a>）接下来我们就来完善具体的功能。</p>
<h2 id="创建项目结构"><a href="#创建项目结构" class="headerlink" title="创建项目结构"></a>创建项目结构</h2><p>我们需要的项目结构大致如下，包含了所需的文件和文件夹（<a href="https://github.com/bimohxh/autogo/tree/master/structure" target="_blank" rel="noopener">详见</a>）。</p>
<p>要创建上面的结构，我们可以通过程序来创建多个文件和文件夹，但是对于这么多文件，而且每个文件里或许还有更多内容，所以我们应该用一个更简便的方法。</p>
<p>实际上我们可以先创建一个完整的结构，然后在执行命令时，通过程序把这些文件和文件夹整个复制到目标项目文件夹中去，最后再对某些文件做一些修改即可。</p>
<p>按照这个思路，我们根据上面的结构，将这些文件和文件夹创建到<code>structure</code>下，然后我们创建一个生成结构的方法<code>lib/generateStructure.js</code>（这里我们将功能模块放在<code>lib/</code>目录下）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'bluebird'</span>),</span><br><span class="line">    fs = <span class="built_in">Promise</span>.promisifyAll(<span class="built_in">require</span>(<span class="string">'fs-extra'</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateStructure</span>(<span class="params">project</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fs.copyAsync(<span class="string">'structure'</span>, project, &#123; <span class="attr">clobber</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = generateStructure;</span><br></pre></td></tr></table></figure>
<p>上面的代码就是通过<code>fs-extra</code>这个包（<a href="https://www.npmjs.com/package/fs-extra" target="_blank" rel="noopener">查看文档</a>）将<code>structure</code>目录下的内容复制到<code>project</code>参数的目标文件夹中。<code>fs-extra</code>是对<code>fs</code>包的一个扩展，方便我们对文件的操作。</p>
<p>这里我们用到了<code>bluebrid</code>（<a href="https://www.npmjs.com/package/bluebird" target="_blank" rel="noopener">查看文档</a>），这是一个实现Promise的库，因为这里牵涉到了对文件的操作，所以会有异步方法，而Promise就是专门解决这些异步操作嵌套回调的，能将其扁平化。</p>
<p>自然，我们应该安装这两个包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install bluebird --save</span><br><span class="line">npm install fs-extra --save</span><br></pre></td></tr></table></figure></p>
<p>这里加上<code>--save</code>参数是为了在安装后自动将该依赖加入到<code>package.json</code>中。然后我们改造一下<code>bin/autogo.js</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"><span class="keyword">var</span> gs = <span class="built_in">require</span>(<span class="string">'../lib/generateStructure'</span>);</span><br><span class="line"></span><br><span class="line">gs(<span class="string">"demo"</span>);</span><br></pre></td></tr></table></figure></p>
<p>然后执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autogo</span><br></pre></td></tr></table></figure></p>
<p>可以看到当前目录下生成了一个<code>demo</code>文件夹，里面包含了和<code>structure</code>相同的文件结构。</p>
<p>我们的目标已经初步达成了，接下来我们就来细化该命令。</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><p>上面的命令中，我们执行<code>autogo</code>时，是生成了一个固定的<code>demo</code>项目，实际上这个名字是不能写死的，而是应该通过命令中的参数传进去。像下面这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autogo demo</span><br></pre></td></tr></table></figure></p>
<p>因此，我们得在<code>bin/autogo.js</code>中去接收参数。为了方便起见，我们这里直接使用一个专门用于处理命令行工具的包<code>commander</code>（<a href="https://www.npmjs.com/package/commander" target="_blank" rel="noopener">文档</a>）。</p>
<p>同样，首先安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install commander --save</span><br></pre></td></tr></table></figure></p>
<p>然后改造<code>bin/autogo.js</code>为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>),</span><br><span class="line">    gs = <span class="built_in">require</span>(<span class="string">'../lib/generateStructure'</span>);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">  .version(<span class="built_in">require</span>(<span class="string">'../package.json'</span>).version)</span><br><span class="line">  .usage(<span class="string">'[options] [project name]'</span>)</span><br><span class="line">  .parse(process.argv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pname = program.args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">gs(pname);</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>.version()</code>意思是返回该命令包的版本号，即运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autogo --version //- 返回1.0.0</span><br></pre></td></tr></table></figure></p>
<p>会返回<code>package.json</code>中定义的版本号。</p>
<p><code>.usage()</code>显示基本使用方法。执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autogo --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>会输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage: autogo [options] [project name]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -h, --<span class="built_in">help</span>      output usage information</span><br><span class="line">    -V, --version   output the version number</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>Commander</code>帮我们做好了用法（<code>Usage</code>）信息，以及两个参数<code>(Options) -h, --help</code>和<code>-V， --version</code>。</p>
<p><code>.parse(process.argv);</code>是将接收到的参数加入<code>Commander</code>的处理管道。</p>
<p><code>program.args</code>是获取到命令后的参数，注意这里是一个数组。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">autogo          //- 返回  []</span><br><span class="line">autogo demo     //- 返回  [<span class="string">'demo'</span>]</span><br><span class="line">autogo demo hello    //- 返回  [<span class="string">'demo'</span>, <span class="string">'hello'</span>]</span><br></pre></td></tr></table></figure></p>
<p>这里我们取第一个参数作为项目名，然后调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pname = program.args[<span class="number">0</span>];</span><br><span class="line">gs(pname);</span><br></pre></td></tr></table></figure></p>
<p>现在我们执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autogo demo2</span><br></pre></td></tr></table></figure></p>
<p>就可以看到新的项目<code>demo2</code>生成了，看上去我们已经完成工作了，只要运行<code>autogo &lt;项目名&gt;</code>就可以生成一个新的项目结构，里面包含了处理<code>Sass</code>、<code>Coffee</code>、<code>jage</code>的<code>gulp</code>构建工具。</p>
<p>如果我们直接运行<code>autogo</code>是会报错的，因为没有传入项目名，实际上我们在运行一个命令而不传入任何参数时，可以直接返回帮助信息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pname = program.args[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (!pname) program.help();</span><br></pre></td></tr></table></figure></p>
<p>上面我们判断是否存在参数，如果不存在就调用<code>program.help()</code>方法，这是<code>commander</code>为我们提供的显示帮助信息的方法，可以直接调用。</p>
<p>那有同学要说了，我不想用<code>jade</code>，就喜欢写原生<code>HTML</code>，很明显我们做了多余的事，而且整个结构就不那么合理了，我们需要的是一个干净的项目结构。</p>
<p>这个时候我们需要把与<code>jade</code>相关的文件删除掉（这里不是删<code>structure</code>目录下的文件，而是新项目下的指定文件）。与<code>jade</code>有关的文件有：<br><code>/structure/views/</code>下的<code>index.jade</code>和<code>layouts/layout.jade</code></p>
<ul>
<li><code>/structure/gulpfile.js</code>中的<code>templates</code>任务代码</li>
</ul>
<p>因此，我们得把上面这些文件和代码干掉。</p>
<h3 id="移除指定模块"><a href="#移除指定模块" class="headerlink" title="移除指定模块"></a>移除指定模块</h3><p>首先，我们创建一个<code>lib/jadeWithout.js</code>用来移除<code>jade</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'bluebird'</span>),</span><br><span class="line">    fs = <span class="built_in">Promise</span>.promisifyAll(<span class="built_in">require</span>(<span class="string">'fs-extra'</span>)),</span><br><span class="line">    del = <span class="built_in">require</span>(<span class="string">'../lib/delFile'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> files = [<span class="string">'/views/layouts/layout.jade'</span>, <span class="string">'/views/index.jade'</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jadeWithout</span>(<span class="params">project</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([del(project, files)])</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'remove jade success'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = jadeWithout;</span><br></pre></td></tr></table></figure></p>
<p>这里我们将指定的files数组中的文件都删除了，这里我们用了一个公共的删除文件模块<code>/lib/delFile.js</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'bluebird'</span>),</span><br><span class="line">    fs = <span class="built_in">Promise</span>.promisifyAll(<span class="built_in">require</span>(<span class="string">'fs-extra'</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params">project, files</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> files.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.removeAsync(project + item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delFile</span>(<span class="params">project, files</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(del[project, files]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = delFile;</span><br></pre></td></tr></table></figure></p>
<p>因为我们这里不光有<code>jade</code>，还有<code>sass</code>和<code>coffee</code>可以被移除，所以我们创建一个公共入口<code>withoutFile.js</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'bluebird'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deal</span>(<span class="params">project, outs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> outs.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> action = <span class="built_in">require</span>(<span class="string">'../lib/'</span> + item + <span class="string">'Without'</span>);</span><br><span class="line">    <span class="keyword">return</span> action(project);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withoutFile</span>(<span class="params">project, outs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([deal(project, outs)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = withoutFile;</span><br></pre></td></tr></table></figure></p>
<p>这里我们需要传入一个要移除的列表(如<code>[&#39;sass&#39;, &#39;jade&#39;]</code>)，然后对每个模块进行删除。<br>最后，我们将<code>withoutFile</code>引入到<code>bin/autogo.js</code>中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gs = reuqire(<span class="string">'../lib/generateStructure'</span>),</span><br><span class="line">    wf = <span class="built_in">require</span>(<span class="string">'../lib/withoutFile'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([gs(pname)])</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> wf(pname, [<span class="string">'jade'</span>, <span class="string">'sass'</span>]);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>然后我们再次执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autogo demo</span><br></pre></td></tr></table></figure></p>
<p>可看到控制台依次输出了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">generate project success</span><br><span class="line">remove jade success</span><br><span class="line">remove sass success</span><br></pre></td></tr></table></figure></p>
<p>而且目标项目中相关文件已经被删除了。</p>
<p>这里我们是<code>wf(pname, [&#39;jade&#39;, &#39;sass&#39;])</code>写死了<code>outs</code>参数作为测试，实际上是要再传入一个数组，那么这个数组从哪里来呢？很明显，得从命令行参数中获取。</p>
<p>我们希望的是这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autogo --without jade demo</span><br></pre></td></tr></table></figure></p>
<h3 id="option"><a href="#option" class="headerlink" title="option"></a>option</h3><p>commander为我们提供了一个option管道来配置命令参数，修改<code>bin/autogo.js</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">    .version(<span class="built_in">require</span>(<span class="string">'../package.json'</span>).version)</span><br><span class="line">    .usage(<span class="string">'[options] [project name]'</span>)</span><br><span class="line">    .option(<span class="string">'-W, --without &lt;str | array&gt;'</span>, <span class="string">'generate project without some models(value can be `sass`, `coffee`, `jade`)'</span>)</span><br><span class="line">    .parse(process.argv);</span><br></pre></td></tr></table></figure></p>
<p>这里我们添加了<code>option</code>，其格式为<code>.option(&#39;-&lt;大写标识&gt;, --&lt;小写全称&gt; &lt;可取参数类型&gt;&#39;, &#39;功能描述&#39;)</code>。</p>
<p>接着处理<code>without</code>参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outs = program.without ? [program.without] : [];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([gs(pname)])</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> wf(pname, outs);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>然后我们再运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autogo --without jade demo</span><br></pre></td></tr></table></figure></p>
<p>可以看到这里只移除了jade模块，那如果我想移除多个呢？是不是可以这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autogo --without [jade, sass] demo</span><br></pre></td></tr></table></figure></p>
<p>注意，这样是会报错的，因为获取到的<code>program.without</code>是一个字符串<code>[jade, sass]</code>而不是数组，所以我们可以这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autogo --without jade,sass demo</span><br></pre></td></tr></table></figure></p>
<p><code>program.without</code>则为<code>jade,sass</code> 然后再<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">program.without.split(<span class="string">','</span>)</span><br></pre></td></tr></table></figure></p>
<p>既可以获取到一个数组了，因此我们的代码就变成了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outs = program.without ? program.without.split(<span class="string">','</span>) : [];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([gs(pname)])</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> wf(pname, outs);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>这下我们就可以这样运行了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autogo demo --without sass,jade</span><br></pre></td></tr></table></figure></p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>到目前为止，我们开发的autogo还是在本地的，现在就该将其发布到<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>上。</p>
<p>1.首先我们得<a href="https://www.npmjs.com/signup" target="_blank" rel="noopener">注册一个账号</a>。</p>
<p>2.回到项目中，执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm login</span><br></pre></td></tr></table></figure></p>
<p>输入用户名、密码和邮箱便可将本地机器与npm连接起来了。</p>
<p>3.执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure></p>
<p>然后回到你的npm个人主页，就可以看到我们发布成功了。<br><a href="https://www.npmjs.com/package/autogo" target="_blank" rel="noopener">https://www.npmjs.com/package/autogo</a></p>
<p>从包的路径规则来看，是没有包含用户名的，由此可知，同名的包是不会被允许的，所以大家在跟着做的时候要给项目取一个不同的名字。</p>
<p>然后我们来测试一下刚刚发布的包</p>
<p>首先删除本地开发做的autogo链接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm unlink</span><br></pre></td></tr></table></figure></p>
<p>然后<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install autogo -g</span><br></pre></td></tr></table></figure></p>
<p>注意这里需要带上<code>-g</code>参数，因为命令行是应该安装在全局环境中。安装成功后，我们切换到另外一个目录下，执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autogo demo</span><br></pre></td></tr></table></figure></p>
<p>然后结果并非我们想象的那样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Unhandled rejection Error: ENOENT, lstat <span class="string">'structure'</span></span><br><span class="line">    at Error (native)</span><br></pre></td></tr></table></figure></p>
<p>意思是找不到<code>structure</code>，这是怎么回事呢？</p>
<p>实际上当我们执行<code>npm install autogo -g</code>的时候，实际上是将命令包安装在了<code>/usr/local/lib/node_modules/autogo</code>下面，所以在执行命令的目录下是找不到<code>structure</code>文件夹的。</p>
<p>那该怎么办呢？我们能想到的就是，得在程序中去获取这个包安装的实际路径。</p>
<p>幸运的是Node给我们提供了<code>__dirname</code>这个变量用于获取当前执行文件的路径。我们在<code>lib/generateStructure.js</code>下<code>console.log(__dirname)</code>会输出<code>/usr/local/lib/node_modules/autogo/lib</code>，然后我们把后面的<code>lib</code>去掉就是根目录了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> root = __dirname.replace(<span class="regexp">/autogo\/lib/</span>, <span class="string">'autogo/'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateStructure</span>(<span class="params">project, outs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fs.copyAsync(root + <span class="string">'structure'</span>, project)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> err ? <span class="built_in">console</span>.error(err) : <span class="built_in">console</span>.log(<span class="string">'generate project'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改后，我们按照下面的方式更新，重新安装，然后<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">autogo demo</span><br><span class="line"><span class="built_in">cd</span> demo</span><br><span class="line">npm install</span><br><span class="line">gulp watch</span><br></pre></td></tr></table></figure></p>
<p>OK，一个新的项目诞生了，准备开发吧…</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>首先修改<code>package.json</code>配置文件中的<code>version</code>字段，比如这里我从<code>0.1.0</code>改成<code>0.1.1</code>（只能大于当前版本），然后再次<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure></p>
<p>即可成功发布新版本。</p>
<p>想将该项目从<code>npm</code>中移除吗？执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unpublish autogo --force</span><br></pre></td></tr></table></figure></p>
<p>附：<a href="https://github.com/bimohxh/autogo" target="_blank" rel="noopener">项目代码</a></p>
<blockquote>
<p>原文出处：<a href="https://www.awesomes.cn/source/12" target="_blank" rel="noopener">https://www.awesomes.cn/source/12</a><br>代码源自：<a href="https://github.com/bimohxh/autogo/blob/master/bin/autogo.js#L1" target="_blank" rel="noopener">autogo.js</a></p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/前端/">前端</a><a href="/tags/Node/">Node</a><a href="/tags/命令行工具/">命令行工具</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/09/01/DNS查找过程/"><span>【转】DNS查找过程</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/09/01/DNS查找过程/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-01T09:30:28.000Z">
          2017-09-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>当我们在浏览器的地址栏输入网址（譬如：<a href="http://www.google.com），然后回车，回车这一瞬间到看到页面到底发生了什么呢？" target="_blank" rel="noopener">www.google.com），然后回车，回车这一瞬间到看到页面到底发生了什么呢？</a></p>
<blockquote>
<p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户</p>
</blockquote>
<p>域名解析是页面加载的第一步，那么域名是如何解析的呢？以Chrome为例：</p>
<ol>
<li><p>Chrome浏览器会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有<a href="http://www.google.com对应的条目，而且没有过期，如果有且没有过期则解析到此结束。" target="_blank" rel="noopener">www.google.com对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</a></p>
</li>
<li><p>如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存，如果找到且没有过期则停止搜索解析到此结束。<br>注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用<code>ipconfig/displaydns</code>来进行查看。</p>
</li>
<li><p>如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于<code>C:\\Windows\System32\drivers\etc</code>），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</p>
</li>
<li><p>如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会想本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则由运营商的DNS服务器带我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找到根域的DNS地址，就会向其发起请求（请问<a href="http://www.google.com这个域名的IP地址是多少？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS，我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它问吧，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.google.com这个域名的IP地址是多少？），com域这台服务器告诉运营商的DNS我不知道www.google.com这个域名的IP地址，但是我知道google.com这个域的DNS地址，你找它去吧，于是运营商的DNS又向google.com这个域名的DNS地址(这个一般就是由域名注册商提供的，像万网，新网等)发起请求（请问www.google.com这个域名的IP地址是多少？），这个时候google.com域的DNS服务器一查，咦，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.google.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.google.com对应的IP地址，该进行下一步的动作了。" target="_blank" rel="noopener">www.google.com这个域名的IP地址是多少？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS，我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它问吧，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.google.com这个域名的IP地址是多少？），com域这台服务器告诉运营商的DNS我不知道www.google.com这个域名的IP地址，但是我知道google.com这个域的DNS地址，你找它去吧，于是运营商的DNS又向google.com这个域名的DNS地址(这个一般就是由域名注册商提供的，像万网，新网等)发起请求（请问www.google.com这个域名的IP地址是多少？），这个时候google.com域的DNS服务器一查，咦，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.google.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.google.com对应的IP地址，该进行下一步的动作了。</a><br>注：一般情况下是不会进行以下步骤的，如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤。</p>
</li>
<li><p>操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和IP地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。</p>
</li>
<li><p>如果第5步也没有成功，那会查询WINS服务器（是NetBIOS名称和IP地址对应的服务器）</p>
</li>
<li><p>如果第6步也没有查询成功，那么客户端就要进行广播查找</p>
</li>
<li><p>如果第7步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）</p>
</li>
</ol>
<p>如果第8步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。</p>
<p>DNS也是开销，通常浏览器查找一个给定域名的IP地址要花费20~120毫秒，在完成域名解析之前，浏览器不能从服务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？</p>
<p>当客户端DNS缓存（浏览器和操作系统）缓存为空时，DNS查找的数量与要加载的Web页面中唯一主机名的数量相同，包括页面URL、脚本、样式表、图片、Flash对象等的主机名。减少主机名的数量就可以减少DNS查找的数量。</p>
<p>减少唯一主机名的数量会潜在减少页面中并行下载的数量（HTTP1.1 规范建议从每个主机名并行下载两个组件，但实际上可以多个），这样减少主机名和并行下载的方案会产生矛盾，需要大家自己权衡。建议将组件放到至少两个但不多于4和主机名下，减少DNS查找的同时也允许高度并行下载。</p>
<p> 转自：<a href="http://www.cnblogs.com/MarcoHan/p/5295398.html" target="_blank" rel="noopener">http://www.cnblogs.com/MarcoHan/p/5295398.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/性能优化/">性能优化</a><a href="/tags/网络请求/">网络请求</a><a href="/tags/DNS/">DNS</a><a href="/tags/转载/">转载</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/09/01/请求头缓存机制/"><span>【转】请求头缓存机制</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/09/01/请求头缓存机制/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-01T06:30:28.000Z">
          2017-09-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><blockquote>
<p>页面的初次访问者会进行很多HTTP请求，但是通过使用一个长久的Expires头，可以使这些组件被缓存，下次访问的时候，就可以减少不必要的HTTP请求，从而提高加载速度。</p>
</blockquote>
<p>Web服务器通过Expires头告诉客户端可以使用一个组件的当前副本，直到指定的时间为止。例如：<br>Expires: Fri, 18 Mar 2016 07:41:53 GMT</p>
<p>Expires缺点：它要求服务器和客户端时钟严格同步；过期日期需要经常检查。</p>
<p>HTTP1.1中引入Cache-Control来克服Expires头的限制，使用max-age指定组件被缓存多久。<br>Cache-Control: max-age=12345600</p>
<p>若同时制定了Cache-Control和Expires，则max-age将覆盖Expires头。</p>
<h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><h4 id="什么是ETag？"><a href="#什么是ETag？" class="headerlink" title="什么是ETag？"></a>什么是ETag？</h4><blockquote>
<p>实体标签（EntityTag）是唯一标识了一个组件的一个特定版本的字符串，是web服务器用于确认缓存组件的有效性的一种机制，通常可以使用组件的某些属性来构造它。</p>
</blockquote>
<h4 id="条件GET请求"><a href="#条件GET请求" class="headerlink" title="条件GET请求"></a>条件GET请求</h4><p>如果组件过期了，浏览器在重用它之前必须首先检查它是否有效。浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。</p>
<p>那么服务器是根据什么判断缓存是否还有效呢？有两种方式：<br>ETag（实体标签）；<br>最新修改日期；</p>
<h5 id="最新修改日期"><a href="#最新修改日期" class="headerlink" title="最新修改日期"></a>最新修改日期</h5><p>原始服务器通过Last-Modified响应头来返回组件的最新修改日期。</p>
<p>举个例子：<br>当我们不带缓存访问的时候，我们需要下载google的logo，这时会发送这样一个HTTP请求：</p>
<p>Request:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET googlelogo_color_272x92dp.png HTTP 1.1</span><br><span class="line">Host: www.google.com.hk</span><br></pre></td></tr></table></figure></p>
<p>Response:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP 1.1 200 OK</span><br><span class="line">Last-Modified: Fri, 04 Sep 2017 22:33:08 GMT</span><br></pre></td></tr></table></figure></p>
<p>请求网址：<a href="https://www.google.com.hk/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png" target="_blank" rel="noopener">https://www.google.com.hk/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png</a><br>请求方法：GET<br>状态码：200 OK</p>
<p>当需要再次访问相同组件的时候，同时缓存已经过期，浏览器会发送如下条件GET请求：</p>
<p>Request：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET googlelogo_color_272x92dp.png HTTP 1.1</span><br><span class="line">If-Modified-Since: Fri, 04 Sep 2017 22:33:08 GMT</span><br><span class="line">Host: www.google.com.hk</span><br></pre></td></tr></table></figure></p>
<p>Response:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP 1.1 304 Not Modified</span><br></pre></td></tr></table></figure></p>
<p>请求网址：<a href="https://www.google.com.hk/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png" target="_blank" rel="noopener">https://www.google.com.hk/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png</a><br>请求方法：GET<br>远程地址：127.0.0.1:1080<br>状态码：304 Not Modified<br>版本：HTTP/2.0</p>
<h5 id="实体标签"><a href="#实体标签" class="headerlink" title="实体标签"></a>实体标签</h5><p>ETag提供了另外一种方式，用于检测浏览器缓存中的组件与原始服务器上组件是否匹配。摘抄自书上的例子：</p>
<p>不带缓存的请求：</p>
<p>Request：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /i/yahoo/gif HTTP 1.1</span><br><span class="line">Host us.yimg.com</span><br></pre></td></tr></table></figure></p>
<p>Response：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP 1.1 200 OK</span><br><span class="line">Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT</span><br><span class="line">ETag: <span class="string">"10c24bc-4ab-457elc1f"</span></span><br></pre></td></tr></table></figure></p>
<p>再次请求相同组件：</p>
<p>Requset：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /i/yahoo/gif http 1.1</span><br><span class="line">Host: us.yimg.com</span><br><span class="line">If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT</span><br><span class="line">If-None-Match: <span class="string">"10c24bc-4ab-457elc1f"</span></span><br></pre></td></tr></table></figure></p>
<p>Response：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP 1.1 304 Not Modified</span><br></pre></td></tr></table></figure></p>
<h4 id="为什么要引入ETag"><a href="#为什么要引入ETag" class="headerlink" title="为什么要引入ETag?"></a>为什么要引入ETag?</h4><p>ETag主要是为了解决Last-Modified无法解决的一些问题：</p>
<ol>
<li><p>一些文件也许会周期性的更改，但是它的内容并不改变（仅仅改变修改时间），这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</p>
</li>
<li><p>某些文件修改非常频繁，比如在秒以下的时间内进行修改，（比方说1s内修改了N次），If-Modified-Since能检查到粒度是s级的，这种修改无法判断（或者说UNIX记录MTIME只能精确到秒）；</p>
</li>
<li><p>某些服务器不能精确的得到文件的最后修改时间。</p>
</li>
</ol>
<h4 id="ETag带来的问题"><a href="#ETag带来的问题" class="headerlink" title="ETag带来的问题"></a>ETag带来的问题</h4><p>ETag的问题在于通常使用某些属性来构造它，有些属性对于特定的部署了网站的服务器来说是唯一的。当使用集群服务器的时候，浏览器从一台服务器上获取了原始组件，之后又向另外一台不同的服务器发起条件GET请求，ETag就会出现不匹配的状况。例如：使用inode-size-timestamp来生成ETag，文件系统使用inode存储文件类型、所有者、组和访问模式等信息，在多台服务器上，就算文件大小、权限、时间戳等都相同，inode也是不同的。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ol>
<li><p>如果使用Last-Modified不会出现任何问题，可以直接移除ETag，google的搜索首页则没有使用ETag。</p>
</li>
<li><p>确定要使用ETag，在配置ETag的值的时候，移除可能影响到组件集群服务器验证的属性，例如使用size-timestamp来生成时间戳。</p>
</li>
</ol>
<p>转自：<a href="http://www.cnblogs.com/MarcoHan/p/5295398.html" target="_blank" rel="noopener">http://www.cnblogs.com/MarcoHan/p/5295398.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/性能优化/">性能优化</a><a href="/tags/网络请求/">网络请求</a><a href="/tags/转载/">转载</a><a href="/tags/缓存机制/">缓存机制</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/2/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/4/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 Xiaolong Lin
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>