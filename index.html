<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>One Pieces</title>

  
  <meta name="author" content="Xiaolong Lin">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="One Pieces"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="One Pieces" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">One Pieces</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/10/什么是云原生/"><span>什么是云原生</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/10/什么是云原生/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-10T07:18:38.000Z">
          2019-07-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <ol>
<li>采用微服务架构</li>
<li>应用容器化</li>
<li>DevOps 管理理念（动态编排）</li>
</ol>
<p>CNCF 对云原生</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/09/Webpack-依赖打包基本原理/"><span>Webpack 依赖打包基本原理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/09/Webpack-依赖打包基本原理/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-09T08:40:15.000Z">
          2019-07-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>今天通过一个简单的例子来说明一下 Webpack 是怎么解决模块依赖的。</p>
<blockquote>
<p>本文使用 webpack 4，<code>mode</code> 为 <code>development</code>，因此其 <code>devtool</code> 为 <code>eval</code>。</p>
</blockquote>
<h2 id="一、生成产物"><a href="#一、生成产物" class="headerlink" title="一、生成产物"></a>一、生成产物</h2><p>首先先来看看下面三个源文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> message <span class="keyword">from</span> <span class="string">'./message.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br><span class="line"></span><br><span class="line"><span class="comment">// message.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">'./name.js'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">`hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">'world'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> text = <span class="string">'text'</span>;</span><br></pre></td></tr></table></figure></p>
<p>Webpack 配置文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./entry.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'entry.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>运行 <code>npx webpack</code>，打包的产物在 <code>dist/entry.js</code>。</p>
<h2 id="二、打包产物分析"><a href="#二、打包产物分析" class="headerlink" title="二、打包产物分析"></a>二、打包产物分析</h2><blockquote>
<p>这里使用了 <code>development</code> 模式，所以产物没有进行最小化处理。</p>
</blockquote>
<p>现在让我们看看产物的整体结构<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="comment">/******/</span>    <span class="comment">// ...</span></span><br><span class="line"><span class="comment">/******/</span> &#125;)</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/******/</span> (&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> <span class="string">"./entry.js"</span>:</span><br><span class="line"><span class="comment">/*!******************!*\</span></span><br><span class="line"><span class="comment">  !*** ./entry.js ***!</span></span><br><span class="line"><span class="comment">  \******************/</span></span><br><span class="line"><span class="comment">/*! no exports provided */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"...// 相关代码"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;),</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> <span class="string">"./message.js"</span>:</span><br><span class="line"><span class="comment">/*!********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./message.js ***!</span></span><br><span class="line"><span class="comment">  \********************/</span></span><br><span class="line"><span class="comment">/*! exports provided: default */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"...// 相关代码"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;),</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> <span class="string">"./name.js"</span>:</span><br><span class="line"><span class="comment">/*!*****************!*\</span></span><br><span class="line"><span class="comment">  !*** ./name.js ***!</span></span><br><span class="line"><span class="comment">  \*****************/</span></span><br><span class="line"><span class="comment">/*! exports provided: name, text */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"...// 相关代码"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<p>初看下产物文件很杂乱，但其实它只是一个闭包。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span> (<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">"./entry.js"</span>);</span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">"./entry.js"</span>: (<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">"...// 相关代码"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>闭包的参数是各个依赖的代码，函数体主要定义了一个 require 函数 <code>__webpack_require__</code>。下面我们分两部分来说明。</p>
<h3 id="1-require-函数-webpack-require"><a href="#1-require-函数-webpack-require" class="headerlink" title="1. require 函数 __webpack_require__"></a>1. require 函数 <code>__webpack_require__</code></h3><p>webpack 最重要的部分就是这个 require 函数。它定义了一个模块变量 module。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">    i: moduleId, <span class="comment">// 模块 ID</span></span><br><span class="line">    l: <span class="literal">false</span>, <span class="comment">// 该模块是否已被加载</span></span><br><span class="line">    exports: &#123;&#125; <span class="comment">// export 出去的代码</span></span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里使用 installedModules 来缓存已加载的模块，如果模块已缓存，则直接返回。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块缓存</span></span><br><span class="line"><span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查模块是否已存在缓存</span></span><br><span class="line">  <span class="keyword">if</span>(installedModules[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个新模块（同时把它放入缓存）</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">    i: moduleId, <span class="comment">// 模块 ID</span></span><br><span class="line">    l: <span class="literal">false</span>, <span class="comment">// 该模块是否已被加载</span></span><br><span class="line">    exports: &#123;&#125; <span class="comment">// export 出去的代码</span></span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>require 函数接收一个 moduleId 参数，用来从闭包参数 modules 里获取对应的模块代码。模块代码被分别封装到一个匿名函数中，require 函数会执行这个模块函数，因此对应模块的代码也会被执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块缓存</span></span><br><span class="line"><span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查模块是否已存在缓存</span></span><br><span class="line">  <span class="keyword">if</span>(installedModules[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个新模块（同时把它放入缓存）</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">    i: moduleId, <span class="comment">// 模块 ID</span></span><br><span class="line">    l: <span class="literal">false</span>, <span class="comment">// 该模块是否已被加载</span></span><br><span class="line">    exports: &#123;&#125; <span class="comment">// export 出去的代码</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 执行模块函数</span></span><br><span class="line">  modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，模块函数的上下文 this 是 <code>module.exports</code>，因此模块的上下文 this 指向的是它本身。</p>
<p>然后模块会被标记为已加载，最终返回模块 export 的内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块缓存</span></span><br><span class="line"><span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查模块是否已存在缓存</span></span><br><span class="line">  <span class="keyword">if</span>(installedModules[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个新模块（同时把它放入缓存）</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">    i: moduleId, <span class="comment">// 模块 ID</span></span><br><span class="line">    l: <span class="literal">false</span>, <span class="comment">// 该模块是否已被加载</span></span><br><span class="line">    exports: &#123;&#125; <span class="comment">// export 出去的代码</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 执行模块函数</span></span><br><span class="line">  modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 标记模块为已加载</span></span><br><span class="line">  <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回模块 export 的内容</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后在闭包内加载入口文件即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载模块入口，并返回 exports</span></span><br><span class="line"><span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">"./entry.js"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-依赖模块"><a href="#2-依赖模块" class="headerlink" title="2. 依赖模块"></a>2. 依赖模块</h3><p>闭包的参数是一个 Object，存放了各个依赖模块。Object 的 key 是模块的 moduleId，值为 <code>import from</code> 的文件路径。Object 的 value 是模块函数，它接收三个参数，<code>module</code>，<code>__webpack_exports__</code>，<code>__webpack_require__</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">    <span class="string">"./message.js"</span>: (<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">      "use strict"</span>;</span><br><span class="line">      <span class="built_in">eval</span>(<span class="string">"__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _name_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./name.js */ \"./name.js\");\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (`hello $&#123;_name_js__WEBPACK_IMPORTED_MODULE_0__[\"name\"]&#125;!`);\n\n//# sourceURL=webpack:///./message.js?"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我们来看看 <code>message.js</code> 生成的代码。因为使用了 <code>eval</code> 模式，webpack 生成的 <code>generated code</code> 被 <code>eval</code> 包裹。可以分为三个部分。</p>
<h4 id="2-1-esModule-定义"><a href="#2-1-esModule-定义" class="headerlink" title="2.1. esModule 定义"></a>2.1. esModule 定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__.r(__webpack_exports__);</span><br></pre></td></tr></table></figure>
<p><code>__webpack_require__.r(__webpack_exports__)</code> 会在 exports 里定义了一个 <code>__esModule</code> 字段，其值为 true，表明这是一个 esModule。</p>
<h4 id="2-2-webpack-require-获取依赖"><a href="#2-2-webpack-require-获取依赖" class="headerlink" title="2.2. __webpack_require__ 获取依赖"></a>2.2. __webpack_require__ 获取依赖</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* harmony import */</span> <span class="keyword">var</span> _name_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="comment">/*! ./name.js */</span> \<span class="string">"./name.js\");</span></span><br></pre></td></tr></table></figure>
<p>然后它通过 <code>__webpack_require__</code> 获取其它模块（<code>name.js</code>）的 exports。</p>
<h4 id="2-3-webpack-exports-暴露依赖"><a href="#2-3-webpack-exports-暴露依赖" class="headerlink" title="2.3. __webpack_exports__ 暴露依赖"></a>2.3. __webpack_exports__ 暴露依赖</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* harmony default export */</span> __webpack_exports__[\<span class="string">"default\"] = (`hello $&#123;_name_js__WEBPACK_IMPORTED_MODULE_0__[\"name\"]&#125;!`);</span></span><br></pre></td></tr></table></figure>
<p>最后在自己的 exports 定义了一个 <code>default</code> 字段，其值为源代码中 <code>exports default</code> 的值。</p>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>可以看出，整个模块依赖是通过 <code>module.exports</code> 进行的。使用 <code>__webpack_require__</code> 函数来获取其它模块的 exports，如果需要向外部提供数据，则使用 <code>__webpack_exports__</code> 将数据暴露到 exports。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/webpack/">webpack</a><a href="/tags/性能优化/">性能优化</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/03/Chrome-Performance-性能分析/"><span>Chrome Performance 性能分析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/03/Chrome-Performance-性能分析/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-03T08:53:56.000Z">
          2019-07-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Chrome 是 Google 公司推出的一款浏览器，根据 NetMarkerShare 最新发布的数据，Chrome 的市场份额达到 66.29%。</p>
</blockquote>
<blockquote>
<p>性能分析是提供良好的用户体验的前提，今天我们通过一个例子来了解一下，如何通过 Chrome 的 Performance 模块对网页进行性能分析。</p>
</blockquote>
<p>一、以用户为中心的性能指标<br>当</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/02/Kruskal’s-最小生成树算法-贪婪算法-2/"><span>Kruskal’s 最小生成树算法 | 贪婪算法-2</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/02/Kruskal’s-最小生成树算法-贪婪算法-2/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-02T11:21:56.000Z">
          2019-07-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>原文：<a href="https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/" target="_blank" rel="noopener">Kruskal’s Minimum Spanning Tree Algorithm | Greedy Algo-2</a></p>
<p><em>什么是最小生成树？</em><br>给定一个连通的无向图，该图的生成树是一个子图，它是一棵将所有顶点连接在一起的树。单个图可以有许多不同的生成树。一个加权连通无向图的最小生成树（MST）或最小权重生成树是指其权重小于或等于所有其他生成树的权重。生成树的权重是树上每条边（edge）的权重的总和。</p>
<p><em>最小生成树有多少条边？</em><br>有 （V-1）条边，其中 V 是图的顶点的个数。</p>
<p><em>最小生成树有什么应用？</em><br>请看<a href="https://www.geeksforgeeks.org/applications-of-minimum-spanning-tree/" target="_blank" rel="noopener">这个</a></p>
<p>下面是使用 Kruskal’s 算法找出 MST 的步骤：</p>
<ol>
<li>按权重的非降序对所有边排序。</li>
<li>选取最小的边。检验当前生成树是否产生环（cycle），如果没有则选择，否则不选取。</li>
<li>重复步骤2 直到生成树有（V-1）条边。</li>
</ol>
<p>步骤2 可以使用联合查找算法（<a href="https://www.geeksforgeeks.org/union-find/" target="_blank" rel="noopener">Union-Find algorithm</a>）检查是否有环。我们建议先查看一下文章：<br><a href="https://www.geeksforgeeks.org/union-find/" target="_blank" rel="noopener">Union-Find Algorithm | Set 1 (Detect Cycle in a Graph)</a><br><a href="https://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/" target="_blank" rel="noopener">Union-Find Algorithm | Set 2 (Union By Rank and Path Compression)</a></p>
<p>这个算法是贪婪算法。贪婪选择的策略是选取权重最小的边，且不会使当前构建的 MST 产生环。让我们通过一个例子来理解它：看看下面的输入图。</p>
<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-0.jpg" alt=""></p>
<p>该图包括 9 个顶点和 14 个边。所以最小生成树将有（9-1）= 8 条边。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">After sorting:</span><br><span class="line">Weight   Src    Dest</span><br><span class="line">1         7      6</span><br><span class="line">2         8      2</span><br><span class="line">2         6      5</span><br><span class="line">4         0      1</span><br><span class="line">4         2      5</span><br><span class="line">6         8      6</span><br><span class="line">7         2      3</span><br><span class="line">7         7      8</span><br><span class="line">8         0      7</span><br><span class="line">8         1      2</span><br><span class="line">9         3      4</span><br><span class="line">10        5      4</span><br><span class="line">11        1      7</span><br><span class="line">14        3      5</span><br></pre></td></tr></table></figure></p>
<p>现在一步步地从排好序的数组里选取所有边。</p>
<ol>
<li>选取边 7-6：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-1.jpg" alt=""></li>
<li>选取边 8-2：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-2.jpg" alt=""></li>
<li>选取边 6-5：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-3.jpg" alt=""></li>
<li>选取边 0-1：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-4.jpg" alt=""></li>
<li>选取边 2-5：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-5.jpg" alt=""></li>
<li>选取边 8-6：由于包含此边会导致环，所以不选取它。</li>
<li>选取边 2-3：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-6.jpg" alt=""></li>
<li>选取边 7-8：由于包含此边会导致环，所以不选取它。</li>
<li>选取边 0-7：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-7.jpg" alt=""></li>
<li>选取边 1-2：由于包含此边会导致环，所以不选取它。</li>
<li>选取边 3-4：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/fig8new.jpeg" alt=""></li>
</ol>
<p>直到包含的变得数目等于（V-1），算法结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有权边</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> src, dest, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连通、无向、有权图</span></span><br><span class="line">sturct Graph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// V 顶点数目，E 边数目</span></span><br><span class="line">    <span class="keyword">int</span> V, E;</span><br><span class="line">    <span class="comment">// 图中的所有边</span></span><br><span class="line">    <span class="comment">// 当图为无向图时，从 src 到 dest 还是从 dest 到 src 都只算一条边</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>* <span class="title">edge</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个有 V 个顶点和 E 条边的图</span></span><br><span class="line"><span class="function">struct Graph* <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span> V, <span class="keyword">int</span> E)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>* <span class="title">graph</span> = <span class="title">new</span> <span class="title">Graph</span>;</span></span><br><span class="line">    graph-&gt;V = V;</span><br><span class="line">    graph-&gt;E = E;</span><br><span class="line">    </span><br><span class="line">    graph-&gt;edge = <span class="keyword">new</span> Edge[E];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合查找的 subset</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">    <span class="keyword">int</span> rank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找集合中元素 i</span></span><br><span class="line"><span class="comment">// 使用路径压缩技巧</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(struct subset subsets[], <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查找根节点 root，然后使 i 的父节点为 root</span></span><br><span class="line">    <span class="comment">// 路径压缩</span></span><br><span class="line">    <span class="keyword">if</span> (subsets[i].parent != i)</span><br><span class="line">        subsets[i].parent = find(subsets, subsets[i].parent);</span><br><span class="line">    <span class="keyword">return</span> subsets[i].parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合两个集合 x 和 y</span></span><br><span class="line"><span class="comment">// 根据 rank 进行联合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(struct subset subsets[], <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xroot = find(subsets, x);</span><br><span class="line">    <span class="keyword">int</span> yroot = find(subsets, y);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 rank 较低的树附加到 rank 较高的树下</span></span><br><span class="line">    <span class="keyword">if</span> (subsets[xroot].rank &lt; subsets[yroot].rank)</span><br><span class="line">        subsets[xroot].parent = yroot;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (subsets[xroot].rank &gt; subsets[yroot].rank)</span><br><span class="line">        subsets[yroot].parent = xroot;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 如果 rank 相同，则使其中一个为 root，且其 rank 增加 1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        subsets[yroot].parent = xroot;</span><br><span class="line">        subsets[xroot].rank++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myComp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>* <span class="title">a1</span> = (<span class="title">struct</span> <span class="title">Edge</span>*)<span class="title">a</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>* <span class="title">b1</span> = (<span class="title">struct</span> <span class="title">Edge</span>*)<span class="title">b</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a1-&gt;weight &gt; b1-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KruskalMST</span><span class="params">(struct Graph* graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V = graph-&gt;V;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> <span class="title">result</span>[<span class="title">V</span>];</span></span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一步：根据权值按非降序对所有边进行排序。</span></span><br><span class="line">    <span class="comment">// 排序不能改变原本的图结构</span></span><br><span class="line">    qsort(graph-&gt;edge, graph-&gt;E, <span class="keyword">sizeof</span>(graph-&gt;edge[<span class="number">0</span>]), myComp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配用于创建 V 个元素的 subsets 的内存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subset</span> *<span class="title">subsets</span> = </span></span><br><span class="line"><span class="class">        (<span class="title">struct</span> <span class="title">subset</span>*) <span class="title">malloc</span>( <span class="title">V</span> * <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">subset</span>) );</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 初始化 V subsets 的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; ++v)</span><br><span class="line">    &#123;</span><br><span class="line">        subsets[v].parent = v;</span><br><span class="line">        subsets[v].rank = <span class="number">0</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (e &lt; V <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第二步：选取最小的边。</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> <span class="title">next_edge</span> = <span class="title">graph</span>-&gt;<span class="title">edge</span>[<span class="title">i</span>++];</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = find(subsets, next_edge.src);</span><br><span class="line">        <span class="keyword">int</span> y = find(subsets, next_edge.dest);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果选取这条边不会造成环，</span></span><br><span class="line">        <span class="comment">// 则包含它到结果数组里，然后增加结果数组的下标</span></span><br><span class="line">        <span class="keyword">if</span> (x != y)</span><br><span class="line">        &#123;</span><br><span class="line">            result[e++] = next_edge;</span><br><span class="line">            Union(subsets, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Following are the edges in the constructed MST\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d -- %d == %d\n"</span>, result[i].src, result[i].dest, result[i].weight);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 给定如下有权图</span></span><br><span class="line"><span class="comment">        10 </span></span><br><span class="line"><span class="comment">    0--------1 </span></span><br><span class="line"><span class="comment">    |  \     | </span></span><br><span class="line"><span class="comment">   6|   5\   |15 </span></span><br><span class="line"><span class="comment">    |      \ | </span></span><br><span class="line"><span class="comment">    2--------3 </span></span><br><span class="line"><span class="comment">        4       */</span></span><br><span class="line">    <span class="keyword">int</span> V = <span class="number">4</span>;  <span class="comment">// 图的顶点数目</span></span><br><span class="line">    <span class="keyword">int</span> E = <span class="number">5</span>;  <span class="comment">// 图的边数目</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>* <span class="title">graph</span> = <span class="title">createGraph</span>(<span class="title">V</span>, <span class="title">E</span>);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增边 0-1</span></span><br><span class="line">    graph-&gt;edge[<span class="number">0</span>].src = <span class="number">0</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">0</span>].dest = <span class="number">1</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">0</span>].weight = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增边 0-2</span></span><br><span class="line">    graph-&gt;edge[<span class="number">1</span>].src = <span class="number">0</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">1</span>].dest = <span class="number">2</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">1</span>].weight = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增边 0-3</span></span><br><span class="line">    graph-&gt;edge[<span class="number">1</span>].src = <span class="number">0</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">1</span>].dest = <span class="number">3</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">1</span>].weight = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增边 1-3</span></span><br><span class="line">    graph-&gt;edge[<span class="number">3</span>].src = <span class="number">1</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">3</span>].dest = <span class="number">3</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">3</span>].weight = <span class="number">15</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增边 2-3</span></span><br><span class="line">    graph-&gt;edge[<span class="number">4</span>].src = <span class="number">2</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">4</span>].dest = <span class="number">3</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">4</span>].weight = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    KruskalMST(graph);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/12/08/27-Mac安装tensorflow使用环境/"><span>27.Mac安装tensorflow使用环境</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/12/08/27-Mac安装tensorflow使用环境/" rel="bookmark">
        <time class="entry-date published" datetime="2018-12-08T07:51:34.000Z">
          2018-12-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要使用 TensorFlow 非常简单。运行 TensorFlow 需要 Python，只需安装好 Python 运行环境，通过 <code>pip</code>包管理器安装即可。</p>
<blockquote>
<p>因为最新的 TensorFlow 不支持 Python 3.7，而使用 Homebrew 安装 python 会默认安装最新版本，即3.7，因此这里不使用 Homebrew。</p>
</blockquote>
<h3 id="1-安装-Python-开发环境"><a href="#1-安装-Python-开发环境" class="headerlink" title="1. 安装 Python 开发环境"></a>1. 安装 Python 开发环境</h3><p>TensorFlow 支持 Python 2 和 Python 3，这里我们选择 Python3。</p>
<blockquote>
<p>要求 Python 3.4，3.5 或者 3.6</p>
</blockquote>
<p>先查看是否安装了 python 环境<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3 --version</span><br><span class="line">pip3 --version</span><br><span class="line">vritualenv --version</span><br></pre></td></tr></table></figure></p>
<p>如果这些包都已经安装，则可以跳过下面步骤到<a href="#2-创建虚拟环境（推荐）">步骤2</a>。否则需要安装 <a href="https://www.python.org/downloads/mac-osx/" target="_blank" rel="noopener">Python</a>，<a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="noopener">pip 包管理器</a>和 <a href="https://virtualenv.pypa.io/en/stable/" target="_blank" rel="noopener">Virtualenv</a>（用来创建隔离的 Python 环境的工具）。</p>
<p>1.1 安装 Python<br>点击 <a href="https://www.python.org/downloads/mac-osx/" target="_blank" rel="noopener">Python 下载</a>，选择对应的 <code>Python 3.6.7 - 2018-10-20</code> 安装包，下载安装到Mac即可。<br><img src="../images/27/1.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否安装成功</span></span><br><span class="line">python3 --version</span><br><span class="line">pip3 --version</span><br></pre></td></tr></table></figure>
<p>1.2 安装 vritualenv<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install -U virtualenv  # system-wide install</span><br></pre></td></tr></table></figure></p>
<h3 id="2-创建虚拟环境（推荐）"><a href="#2-创建虚拟环境（推荐）" class="headerlink" title="2. 创建虚拟环境（推荐）"></a>2. 创建虚拟环境（推荐）</h3><p>Python 虚拟环境用于将软件包的安装与系统环境进行隔离。</p>
<p>2.1 首先创建一个新的虚拟环境，这里我们需要选择一个 Python 解析器和创建一个<code>./venv</code>目录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv --system-site-packages -p python3 ./venv</span><br></pre></td></tr></table></figure></p>
<p>2.2 使用 source 命令激活虚拟环境。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ./venv/bin/activate  <span class="comment"># sh, bash, ksh, or zsh</span></span><br></pre></td></tr></table></figure></p>
<p>2.3 当虚拟环境被激活时，你的 shell 提示符前缀为<code>(venv)</code>。在虚拟环境中安装软件包，不会影响主机系统设置。<br>首先升级<code>pip</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip install --upgrade pip</span><br><span class="line"></span><br><span class="line">(venv) $ pip list  <span class="comment"># show packages installed within the virtual environment</span></span><br></pre></td></tr></table></figure></p>
<p>接着退出<code>virtualenv</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ deactivate  <span class="comment"># don't exit until you're done using TensorFlow</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-安装-TensorFlow-pip包"><a href="#3-安装-TensorFlow-pip包" class="headerlink" title="3. 安装 TensorFlow pip包"></a>3. 安装 TensorFlow pip包</h3><p>选择以下 TensorFlow 软件包的一个进行安装：</p>
<ul>
<li><code>tensorflow</code> —— 仅适用于CPU的当前版本（推荐初学者使用）</li>
<li><code>tensorflow-gpu</code> —— <a href="https://tensorflow.google.cn/install/gpu" target="_blank" rel="noopener">支持GPU</a>的当前版本（<code>Ubuntu</code> 和 <code>Windows</code>）</li>
<li><code>tf-nightly</code> —— 仅适用于CPU的每晚构建版本（不稳定）</li>
<li><code>tf-nightly-gpu</code> —— <a href="https://tensorflow.google.cn/install/gpu" target="_blank" rel="noopener">支持GPU</a>的每晚构建版本（不稳定，<code>Ubuntu</code> 和 <code>Windows</code>）</li>
</ul>
<blockquote>
<p>软件包的依赖项都会自动安装。这些列在<code>REQUIRED_PACKAGES</code>下的<a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/tools/pip_package/setup.py" target="_blank" rel="noopener"><code>setup.py</code></a>文件中。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip install --upgrade tensorflow</span><br></pre></td></tr></table></figure>
<p>验证是否安装成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python -c <span class="string">"import tensorflow as tf; tf.enable_eager_execution(); print(tf.reduce_sum(tf.random_normal([1000, 1000])))"</span></span><br></pre></td></tr></table></figure></p>
<p>如果输出结果，则说明 TensorFlow 安装成功！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://tensorflow.google.cn/install/pip?lang=python3" target="_blank" rel="noopener">https://tensorflow.google.cn/install/pip?lang=python3</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/TensorFlow/">TensorFlow</a><a href="/tags/Python/">Python</a><a href="/tags/机器学习/">机器学习</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/12/05/26-node-js文件流/"><span>26.node.js文件流</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/12/05/26-node-js文件流/" rel="bookmark">
        <time class="entry-date published" datetime="2018-12-05T06:06:03.000Z">
          2018-12-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="1-流的基本概念"><a href="#1-流的基本概念" class="headerlink" title="1.流的基本概念"></a>1.流的基本概念</h3><p>在一个应用程序中，流是一组有序的、有起点和终点的字节数据的传输手段。在应用程序中各种对象之间交换与传输数据时，总是先将该对象中所包含的数据转换为各种形式的流数据（即字节数据），再通过流的传输，到达目标对象后再将数据转换为该对象中可以使用的数据。</p>
<p>在 Node.js 中，我们可以使用实现了 <code>stream.Readable</code> 或 <code>stream.Writeable</code> 接口的对象来将对象数据读取为流数据，或者将流数据写入到对象中。它们都继承了 <code>EventEmitter</code> 类的实例对象，在读取数据或写入数据的过程中，将可能触发各种事件。</p>
<h5 id="表1-1-Node-js中的各种用于读取数据的对象"><a href="#表1-1-Node-js中的各种用于读取数据的对象" class="headerlink" title="表1-1 Node.js中的各种用于读取数据的对象"></a><center>表1-1 Node.js中的各种用于读取数据的对象</center></h5><table>
<thead>
<tr>
<th>对象</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fs.ReadStream</td>
<td>用于读取文件</td>
</tr>
<tr>
<td>http.IncomingMessage</td>
<td>代表客户端请求或服务器端响应</td>
</tr>
<tr>
<td>net.Socket</td>
<td>代表一个 socket 端口对象</td>
</tr>
<tr>
<td>child.stdout</td>
<td>用于创建子进程的标准输出流。如果子进程与父进程共享输入输出流，则子进程的标准输出流被废弃</td>
</tr>
<tr>
<td>child.stderr</td>
<td>用于创建子进程的标准错误输出流。如果子进程与父进程共享输入输出流，则子进程的标准错误输出流被废弃</td>
</tr>
<tr>
<td>process.stdin</td>
<td>用于创建进程的标准输入流</td>
</tr>
<tr>
<td>Gzip<br> Deflate<br> DeflateRaw</td>
<td>用于实现数据压缩</td>
</tr>
</tbody>
</table>
<h5 id="表1-2-读取数据的对象将会触发的事件"><a href="#表1-2-读取数据的对象将会触发的事件" class="headerlink" title="表1-2 读取数据的对象将会触发的事件"></a><center>表1-2 读取数据的对象将会触发的事件</center></h5><table>
<thead>
<tr>
<th>事件名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>readable</td>
<td>当可以从流中读出数据时触发。在大多数情况下，如果指定了 <code>readable</code> 事件的回调函数，将迫使操作系统将流数据首先读入操作系统缓存区中，然后再从操作系统缓存区中读出数据，当操作系统缓存区中对象被全部读出，且可以继续从流中读取数据时，将触发一个新的 <code>readable</code> 事件</td>
</tr>
<tr>
<td>data</td>
<td>当读取到来自于文件、客户端、服务器端等对象的新的数据时触发 <code>data</code> 事件。如果指定 <code>data</code> 事件的回调函数，将使用 <code>flowing</code> 模式来读取流数据（在 Node.js 中，可以使用 <code>flowing</code> 模式与 非 <code>flowing</code> 模式来读取数据。当使用 <code>flowing</code> 模式时，将使用操作系统的内部 I/O 机制来读取数据，，这允许你以最快速度读取数据。当使用非 <code>flowing</code> 模式时，你必须显式调用对象的 <code>read</code> 方法来读取数据）。参数值为存放了已读取到的数据的缓存区对象或一个字符串（当对流数据指定编码格式时）</td>
</tr>
<tr>
<td>end</td>
<td>当读取完所有数据时触发，该事件的触发意味着 <code>data</code> 事件将不再被触发</td>
</tr>
<tr>
<td>error</td>
<td>当读取数据过程中产生错误时触发</td>
</tr>
<tr>
<td>close</td>
<td>当用于读取流数据的对象被关闭时触发。并非所有用于读取流数据的对象都会触发该事件</td>
</tr>
</tbody>
</table>
<h5 id="表1-3-读取数据的对象的方法"><a href="#表1-3-读取数据的对象的方法" class="headerlink" title="表1-3 读取数据的对象的方法"></a><center>表1-3 读取数据的对象的方法</center></h5><table>
<thead>
<tr>
<th>事件名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>read</td>
<td>用于读取数据</td>
</tr>
<tr>
<td>setEncoding</td>
<td>用于指定用什么编码方式读取数据</td>
</tr>
<tr>
<td>pause</td>
<td>用于通知对象停止触发 <code>data</code> 事件</td>
</tr>
<tr>
<td>resume</td>
<td>用于通知对象恢复触发 <code>data</code> 事件</td>
</tr>
<tr>
<td>pipe</td>
<td>用于设置一个数据通道，然后取出所有流数据并将其输出到通道另一端所指向的目标对象中</td>
</tr>
<tr>
<td>unpipe</td>
<td>用于取消在 <code>pipe</code> 方法中设置的通道</td>
</tr>
<tr>
<td>unshift</td>
<td>当对流数据绑定了一个解析器时，可以使用 <code>unshift</code> 方法来取消该解析器的绑定，使流数据可以通过其他方式解析</td>
</tr>
</tbody>
</table>
<h5 id="表1-4-Node-js中的各种用于写入数据的对象"><a href="#表1-4-Node-js中的各种用于写入数据的对象" class="headerlink" title="表1-4 Node.js中的各种用于写入数据的对象"></a><center>表1-4 Node.js中的各种用于写入数据的对象</center></h5><table>
<thead>
<tr>
<th>对象</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fs.WriteStream</td>
<td>用于写入文件</td>
</tr>
<tr>
<td>http.ClientRequest</td>
<td>用于写入 HTTP 客户端请求数据</td>
</tr>
<tr>
<td>http.ServerResponse</td>
<td>用于写入 HTTP 服务端响应数据</td>
</tr>
<tr>
<td>net.Socket</td>
<td>用于读写 TCP 流或 UNIX 流，可被用户创建并作为一个客户端来使用，也可被 Node.js 脚本程序创建并通过服务器的 connection 事件来传递给用户</td>
</tr>
<tr>
<td>child.stdin</td>
<td>用于创建子进程的标准输入流。使用该对象的 close 方法将终止子进程。如果子进程与父进程共享输入输出流，则子进程的标准输入流数据被废弃</td>
</tr>
<tr>
<td>process.stdout</td>
<td>用于创建进程的标准输出流</td>
</tr>
<tr>
<td>process.stderr</td>
<td>用于创建进程的标准错误输出流</td>
</tr>
<tr>
<td>Gunzip<br> Inflate<br> InflateRaw</td>
<td>用于解压数据</td>
</tr>
</tbody>
</table>
<h5 id="表1-5-写入数据的对象将会触发的事件"><a href="#表1-5-写入数据的对象将会触发的事件" class="headerlink" title="表1-5 写入数据的对象将会触发的事件"></a><center>表1-5 写入数据的对象将会触发的事件</center></h5><table>
<thead>
<tr>
<th>事件名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>drain</td>
<td>当用于写入数据的 write 方法返回 false 之后触发，表示操作系统缓存区中的数据已全部输出到目标对象中，可以继续向操作系统缓存区写入数据</td>
</tr>
<tr>
<td>finish</td>
<td>当 end 方法被调用且数据被全部写入操作系统缓存区时触发</td>
</tr>
<tr>
<td>pipe</td>
<td>当用于读取数据的对象的 pipe 方法被调用时触发</td>
</tr>
<tr>
<td>unpipe</td>
<td>当用于读取数据的对象的 unpipe 方法被调用时触发</td>
</tr>
<tr>
<td>error</td>
<td>当写入数据的过程中产生错误时触发</td>
</tr>
</tbody>
</table>
<h5 id="表1-6-写入数据的对象的方法"><a href="#表1-6-写入数据的对象的方法" class="headerlink" title="表1-6 写入数据的对象的方法"></a><center>表1-6 写入数据的对象的方法</center></h5><table>
<thead>
<tr>
<th>事件名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>write</td>
<td>用于写入数据</td>
</tr>
<tr>
<td>end</td>
<td>当没有数据再被写入流中时调用该方法，这将迫使操作系统缓存区中的剩余数据被立即写入目标对象中。当该方法被调用后，将不能继续在目标对象中写入数据</td>
</tr>
</tbody>
</table>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/node-js/">node.js</a><a href="/tags/文件流/">文件流</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/21/25-Promise原理及实现/"><span>25.Promise原理及实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/21/25-Promise原理及实现/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-21T12:42:27.000Z">
          2018-11-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>上一篇文章 <a href="http://one-pieces.me/2018/11/14/24-Promises-A-%E8%A7%84%E8%8C%83/" target="_blank" rel="noopener">24.Promises/A+ 规范</a> 介绍了Promises/A+ 规范，我们来手动实现一个符合 Promises/A+ 规范的自己的Promise。</p>
<p>根据规范，Promise 共有三种状态 <code>pending</code>，<code>fulfilled</code>，<code>rejected</code>，我们使用 <code>state</code> 来表示 promise 当前的状态，使用 <code>value</code> 来表示当前<code>值</code>或<code>原因</code>。当然还有最重要的 <code>then</code> 方法。同时我们还需要一些辅助函数，比如 <code>isFunction</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.1</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.state = PENDING;</span><br><span class="line">  <span class="comment">// 值或原因</span></span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 2.2.1</span></span><br><span class="line">  <span class="keyword">if</span> (isFunction(onFulfilled) || isFunction(onRejected)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.onFulfilled = onFulfilled;</span><br><span class="line">    <span class="keyword">this</span>.onRejected = onRejected;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据2.2.7，</span></span><br><span class="line">  <span class="comment">// then必须返回一个 promise，但它还有其他的规则，</span></span><br><span class="line">  <span class="comment">// 这里我们先不管，直接返回当前 promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> func === <span class="string">'function'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，我们定义两个函数，可以将 promise 转换为 <code>fulfilled</code> 或 <code>rejected</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doResolve</span> (<span class="params">promise, value</span>) </span>&#123;</span><br><span class="line">  promise.state = FULFILLED;</span><br><span class="line">  promise.value = value;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isFunction(promise.onFulfilled)) &#123;</span><br><span class="line">    <span class="comment">// 2.2.4</span></span><br><span class="line">    <span class="comment">// 需要确保onFulfilled和onRejected的异步执行，</span></span><br><span class="line">    <span class="comment">// 是在调用then的事件轮训时间片之后，且调用栈为空。</span></span><br><span class="line">    <span class="comment">// 更多详情可看http://one-pieces.me/2018/11/14/24-Promises-A-%E8%A7%84%E8%8C%83/#3-%E6%B3%A8%E9%87%8A</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      promise.onFulfilled(promise.value);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doReject</span> (<span class="params">promise, reason</span>) </span>&#123;</span><br><span class="line">  promise.state = REJECTED;</span><br><span class="line">  promise.value = reason;</span><br><span class="line">  <span class="keyword">if</span> (isFunction(promise.onRejected)) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      promise.onRejected(promise.value);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们还需要一个 resolver，将刚才定义的 <code>doResolve</code> 和 <code>doReject</code> 暴露给 Promise 的构造函数。想想我们平时是怎么 new 一个 Promise的？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safelyResolveThen</span>(<span class="params">promise, then</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      doResolve(promise, value);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      doReject(promise, reason);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    doReject(promise, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后修改 Promise 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">resolver</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.state = PENDING;</span><br><span class="line">  <span class="comment">// 值或原因</span></span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">  safelyResolveThen(<span class="keyword">this</span>, resolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，Promise 最核心的功能已经实现。可以很容易地看出，这里 Promise 的底层实现使用了<code>回调（callback）</code></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/14/24-Promises-A-规范/"><span>24.Promises/A+ 规范</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/14/24-Promises-A-规范/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-14T09:13:13.000Z">
          2018-11-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>(原文 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promises/A+</a>)</p>
<p>一个具有互操作性的 JavaScript promises 的开源标准。</p>
<p>一个 promise 代表着异步操作的最终结果。与 promise 进行交互的主要方式是通过then方法，该方法注册回调来接收 promise 的最终值或 promise 无法完成（失败）的原因。</p>
<p>该规范详细说明了then方法的行为，它提供了一个可互操作的标准，使所有符合 Promises/A+ 规范的 promise 依据该标准来实现。因此，该规范应该被认为是非常稳定（stable）的。即使 Promises/A+ 组织偶尔会修改该规范，只是为了解决新发现的极端问题而加入一些比较小的向后兼容的更改，但只有经过仔细考虑，讨论和测试后，我们才会整合大的或向后不兼容的改动。</p>
<p>Promises/A+ 阐明了早期的 Promises/A 提案的行为条款，并将其扩展，使其覆盖到现实中的例子，且忽略了未确定和有问题的部分。</p>
<p>最后，该 Promises/A+ 规范的核心并不是规定如何新建（create），完成（fulfill），拒绝（reject） promises，而是专注于提供一个可互操作的then方法。相关规范的后续工作可能会涉及到这些主题。</p>
<h3 id="1-术语"><a href="#1-术语" class="headerlink" title="1. 术语"></a>1. 术语</h3><p>1.1 “promise” 是一个具有符合该规范规定行为的then方法的对象或函数</p>
<p>1.2 “thenable” 是一个定义了then方法的对象或函数。</p>
<p>1.3 <code>值</code>（”value”） 是任意合法的JavaScript的值（包括<code>undefined</code>，一个 thenable，或者一个 promise）。</p>
<p>1.4 <code>异常</code>（”exception”） 是 一个使用了<code>throw</code>语法抛出的值</p>
<p>1.5 <code>原因</code>（”reason”） 是一个表示为什么 promise 被拒绝的原因。</p>
<h3 id="2-要求"><a href="#2-要求" class="headerlink" title="2. 要求"></a>2. 要求</h3><h4 id="2-1-Promise状态"><a href="#2-1-Promise状态" class="headerlink" title="2.1 Promise状态"></a>2.1 Promise状态</h4><p>一个 Promise 必须处在以下三种状态中的一个：<code>pending</code>，<code>fulfilled</code>，<code>rejected</code>。</p>
<ul>
<li><p>2.1.1 当状态为<code>pending</code>时：  </p>
<ul>
<li>2.1.1.1 可以转换到<code>fulfilled</code>或者<code>rejected</code>。</li>
</ul>
</li>
<li><p>2.1.2 当状态为<code>fulfilled</code>时：</p>
<ul>
<li>2.1.2.1 不能转换为其它状态。</li>
<li>2.1.2.2 必须有一个不可修改的<code>值(value)</code>。</li>
</ul>
</li>
<li><p>2.1.3 当状态为<code>rejected</code>时：</p>
<ul>
<li>2.1.3.1 不能转换为其它状态。</li>
<li>2.1.3.2 必须有一个不可修改的<code>原因(reason)</code>。</li>
</ul>
</li>
</ul>
<p>上文的“不可修改”的含义是一旦创建就不能被修改（类似<code>===</code>），但并不意味着这个不可变性是深嵌套的。</p>
<h4 id="2-2-then方法"><a href="#2-2-then方法" class="headerlink" title="2.2 then方法"></a>2.2 <code>then</code>方法</h4><p>一个 promise 必须提供一个<code>then</code>方法去获取它当前或最终的<code>值</code>或<code>原因</code>。</p>
<p>一个 promise 的<code>then</code>方法接收两个参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>2.2.1 <code>onFulfilled</code>和<code>onRejected</code>都是可选参数：</p>
<ul>
<li>2.2.1.1 如果<code>onFulfilled</code>不是函数，则必须忽略它。</li>
<li>2.2.1.1 如果<code>onRejected</code>不是函数，则必须忽略它。</li>
</ul>
</li>
<li><p>2.2.2 如果<code>onFulfilled</code>是函数：</p>
<ul>
<li>2.2.2.1 则必须在 promise 状态转换为<code>fulfilled</code>之后调用它，且它的第一个参数为 promise 的<code>值</code>。</li>
<li>2.2.2.2 不能在 promise 状态转换为<code>fulfilled</code>之前调用它。</li>
<li>2.2.2.2 不能多次调用它。</li>
</ul>
</li>
<li><p>2.2.3 如果<code>onRejected</code>是函数：</p>
<ul>
<li>2.2.3.1 则必须在 promise 状态转换为<code>rejected</code>之后调用它，且它的第一个参数为 promise 的<code>原因</code>。</li>
<li>2.2.3.2 不能在 promise 状态转换为<code>rejected</code>之前调用它。</li>
<li>2.2.3.2 不能多次调用它。</li>
</ul>
</li>
<li><p>2.2.4 在执行上下文堆栈中仅包含平台代码<a href="#3-注释">[3.1]</a>之前，不能调用<code>onFulfilled</code>或<code>onRejected</code>。</p>
</li>
<li><p>2.2.5 <code>onFulfilled</code>和<code>onRejected</code>必须作为函数被调用（即没有<code>this</code>值）。<a href="#3-注释">[3.2]</a></p>
</li>
<li><p>2.2.6 同一个 promise 上的<code>then</code>可以被多次调用。</p>
<ul>
<li>2.2.6.1 如果/当 promise 为<code>fulfilled</code>时，所有相应的<code>onFulfilled</code>回调必须按其原本的调用顺序执行。</li>
<li>2.2.6.1 如果/当 promise 为<code>onRejected</code>时，所有相应的<code>onRejected</code>回调必须按其原本的调用顺序执行。</li>
</ul>
</li>
<li><p>2.2.7 <code>then</code>必须返回一个 promise。<a href="#3-注释">[3.3]</a></p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>
<ul>
<li>2.2.7.1 如果<code>onFulfilled</code>或<code>onRejected</code>返回一个<code>值</code>x，则运行 Promise 解析器（Promise Resolution Procedure）<code>[[Resolve]](promise2, x)</code>。</li>
<li>2.2.7.2 如果<code>onFulfilled</code>或<code>onRejected</code>返回一个<code>异常（exception）</code>e，则 promise2 必须以e为<code>原因</code>被拒绝。</li>
<li>2.2.7.3 如果<code>onFulfilled</code>不是函数且 promise1 为<code>fulfilled</code>，promise2 必须以与 promise1 相同的<code>值</code>被完成。</li>
<li>2.2.7.3 如果<code>onRejected</code>不是函数且 promise1 为<code>rejected</code>，promise2 必须以与 promise1 相同的<code>原因</code>被拒绝。</li>
</ul>
</li>
</ul>
<h4 id="2-3-Promise解析器"><a href="#2-3-Promise解析器" class="headerlink" title="2.3 Promise解析器"></a>2.3 Promise解析器</h4><p>Promise 解析器（promise resolution procedure）是一个抽象操作，它将 promise 和<code>值</code>作为输入，我们将其表示为<code>[[Resolve]](promise, x)</code>。如果<code>x</code>是<code>thenable</code>，它会使 promise 采用<code>x</code>的状态，假设<code>x</code>的行为至少有点像 promise。否则，它将以<code>x</code>为<code>值</code>完成 promise。</p>
<p>对<code>thenable</code>的这种处理使得 promise 具有互操作性，只要它们暴露出一个符合 Promises/A+ 规范的<code>then</code>方法。它还允许符合 Promises/A+ 规范的实现使用合理的<code>then</code>方法与“同化”不一致的实现。</p>
<p>为了运行<code>[[Resolve]](promise, x)</code>，需要实现以下几点：</p>
<ul>
<li>2.3.1 如果 promise 和<code>x</code>引用了同个对象，则用<code>TypeError</code>作为<code>原因</code>去拒绝 promise。</li>
<li><p>2.3.2 如果<code>x</code>是 promise，则采用它的状态：<a href="#3-注释">[3.4]</a></p>
<ul>
<li>2.3.2.1 如果<code>x</code>状态为<code>pending</code>，promise 必须保持<code>pending</code>直到<code>x</code>被完成或被拒绝。</li>
<li>2.3.2.2 如果/当<code>x</code>为<code>fulfilled</code>，用相同的<code>值</code>去完成 promise。</li>
<li>2.3.2.3 如果/当<code>x</code>为<code>rejected</code>，用相同的<code>原因</code>去拒绝 promise。</li>
</ul>
</li>
<li><p>2.3.3 否则，如果<code>x</code>是一个对象或函数，</p>
<ul>
<li>2.3.3.1 让<code>then</code>等于<code>x.then</code>。<a href="#3-注释">[3.5]</a></li>
<li>2.3.3.2 如果检测到属性<code>x.then</code>会导致抛出异常<code>e</code>，则用<code>e</code>作为<code>原因</code>去拒绝 promise。</li>
<li>2.3.3.3 如果<code>then</code>是函数（译者注，也就是<code>x</code>为<code>thenable</code>），则将<code>x</code>作为<code>this</code>调用它，第一个参数为<code>resolvePromise</code>，第二个参数为<code>rejectPromise</code>，其中：<ul>
<li>2.3.3.3.1 如果/当<code>resolvePromise</code>被调用且参数为<code>y</code>时，执行<code>[[Resolve]](promise, y)</code>。</li>
<li>2.3.3.3.2 如果/当<code>rejectPromise</code>被调用且参数为<code>r</code>时，则以<code>r</code>为<code>原因</code>拒绝 promise。</li>
<li>2.3.3.3.3 如果<code>resolvePromise</code>和<code>rejectPromise</code>都被调用，或者对同一个参数进行多次调用时，则处理第一次调用，且忽略后续调用。</li>
<li>2.3.3.3.4 如果调用<code>then</code>时抛出一个异常<code>e</code>，<ul>
<li>2.3.3.3.4.1 如果已调用<code>resolvePromise</code>或<code>rejectPromise</code>，请忽略它。</li>
<li>2.3.3.3.4.2 否则，以<code>e</code>作为<code>原因</code>拒绝 promise。</li>
</ul>
</li>
</ul>
</li>
<li>2.3.3.4 如果<code>then</code>不是函数，则以<code>x</code>作为<code>值</code>完成 promise。</li>
</ul>
</li>
<li>2.3.4 如果<code>x</code>不是一个对象或函数，则以<code>x</code>作为<code>值</code>完成 promise。</li>
</ul>
<p>如果使用了在<code>thenable</code>循环链（<code>thenable</code>的<code>then</code>是<code>thenable</code>）上的<code>thenable</code>去解决 promise，那么<code>[[Resolve]](promise, thenable)</code>的递归性质最终会导致<code>[[Resolve]](promise, thenable)</code>再次被调用，上述算法将导致无限递归。我们鼓励（但不是必需）对此类递归逻辑进行检测，如果有，则以一个信息性的<code>TypeError</code>作为<code>原因</code>去拒绝 promise。<a href="#3-注释">[3.6]</a></p>
<h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h3><ul>
<li><p>3.1 这里的<code>平台代码</code>特指执行引擎，运行环境和 promise 实现的代码。在实践中，这个要求确保了<code>onFulfilled</code>和<code>onRejected</code>的异步执行，是在调用<code>then</code>的事件轮训时间片之后，且调用栈为空。这可以使用诸如 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#timers" target="_blank" rel="noopener">setTimeout</a> 或 <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html#processingmodel" target="_blank" rel="noopener">setImmediate</a> 之类的<code>宏任务</code>机制，或者 <a href="https://dom.spec.whatwg.org/#interface-mutationobserver" target="_blank" rel="noopener">MutationObserver</a> 或 <a href="https://nodejs.org/api/process.html#process_process_nexttick_callback" target="_blank" rel="noopener">process.nextTick</a> 之类的<code>微任务</code>机制来实现。由于 promise 的实现代码被认为是平台代码，因此它本身可能包含一个任务调度队列或<code>trampoline（跳板）</code>来调用处理程序。</p>
</li>
<li><p>3.2 也就是说，在严格模式（<code>use strict</code>）下，<code>this</code>将是<code>undefined</code>；在松散模式（<code>sloppy mode</code>）下，<code>this</code>将会是全局对象。</p>
</li>
<li><p>3.3 如果具体实现满足所有要求，我们可以允许<code>promise2 === promise1</code>。每个具体实现都应该说明它是否可以支持<code>promise2 === promise1</code>，以及在什么条件下支持。</p>
</li>
<li><p>3.4 一般来说，如果它来自于当前的具体实现，那<code>x</code>可以被认为是一个真正的 promise。这个条款允许我们使用特定的实现手段，让我们可以去获取被认为符合规范（译者注，比如一个自行实现了<code>then</code>方法的对象）的 promises 的状态。</p>
</li>
<li><p>3.5 该步骤需先存储<code>x.then</code>的引用，后续测试和调用的都是该引用，这样可以避免多次访问<code>x.then</code>属性。这些预防措施对于保证可访问属性的一致性非常重要。可访问属性的值可能会在检索之间发生变化。</p>
</li>
<li><p>3.6 该实现不应该对<code>thenable</code>链的深度设置某个限制值，假设超过这个限制值之后会发生无限递归。只有真正的循环才会引起一个<code>TypeError</code>错误；如果是不同的<code>thenable</code>组成一个无穷的调用链，那么一直递归其实是正确的行为。</p>
</li>
</ul>
<p>在法律允许的范围内，Promises/A+ 组织已放弃 Promises/A+ Promise 规范的所有版权，以及相关或相近的权利。该声明发表于：美国。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Promise/">Promise</a><a href="/tags/规范/">规范</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/09/23-客户端JavaScript执行的时间线/"><span>23.浏览器JavaScript执行的时间线</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/09/23-客户端JavaScript执行的时间线/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-09T07:29:40.000Z">
          2018-11-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道浏览器的渲染线程和脚本线程是互斥的，JavaScript会阻塞浏览器HTML解析器，这也是为什么长时间的脚本运行可能会导致页面失去响应。因此，我们通常会把<code>&lt;script&gt;</code>放在<code>&lt;/body&gt;</code>之前，来保证非脚本的其他一切元素能尽快地得到加载和解析。<br>然而，我们可以通过设置<code>&lt;scirpt&gt;</code>的<code>async</code>和<code>defer</code>来改变<code>&lt;script&gt;</code>的加载和执行顺序。在说这具体是怎样之前,我们先介绍一下浏览器JavaScript执行的时间线。</p>
<h2 id="JavaScript的执行"><a href="#JavaScript的执行" class="headerlink" title="JavaScript的执行"></a>JavaScript的执行</h2><ol>
<li><p>浏览器创建<code>Document</code>对象，并且开始解析Web页面，解析HTML元素和它们的文本内容后，会添加Element对象和Text节点到文档中。在这个阶段document.readystate属性的值是<code>loading</code>。</p>
</li>
<li><p>当HTML解析器遇到没有<code>async</code>和<code>defer</code>属性的<code>&lt;script&gt;</code>元素时，它把这些元素添加到文档中，然后执行行内或者外部脚步。这些脚本会同步执行，并且在脚本下载（如果需要）和执行时，HTML解析器会暂停。这样脚本就可以用<code>document.write()</code>来把文本插入到输入流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单定义函数和注册后面使用的注册事件处理程序，但它们可以遍历和操作文档树，因为在它们执行时已经存在了。这样，同步脚本可以看到它自己的<code>&lt;script&gt;</code>元素和它们之前的文档内容。</p>
</li>
<li><p>当解析器遇到设置了<code>async</code>属性的<code>&lt;script&gt;</code>元素时，它开始下载脚本文本，并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器没有停下来等它下载。异步脚本禁止使用<code>document.write()</code>方法。它们可以看到自己的<code>&lt;script&gt;</code>元素和它之前的所有文档元素，并且可能或干脆不访问其他的文档内容。</p>
</li>
<li><p>当文档完成解析，<code>document.readyState</code>属性变成<code>interactive</code>。</p>
</li>
<li><p>所有有<code>defer</code>属性的脚本，会按它们在文档里的出现顺序执行。异步脚本可能也会在这个时间执行。延迟脚本能访问完整的文档树，禁止使用<code>document.write()</code>方法。</p>
</li>
<li><p>浏览器在<code>Document</code>对象上触发<code>DOMContentLoaded</code>事件。这标志着程序执行从同步脚本执行阶段转换到了异步事件驱动阶段。但要注意，这时可能还有异步脚本没有执行完成。</p>
</li>
<li><p>这时，文档已经完全解析完成，但是浏览器可能还在等待其他内容载入，比如图片。当所有这些内容完成载入时，并且所有异步脚本完成载入和执行，<code>document.readyState</code>属性改变为<code>complete</code>，浏览器触发<code>Window</code>对象上的<code>load</code>事件。</p>
</li>
<li><p>从此刻起，会调用异步事件，以异步响应用户输入事件、网络事件、计时器过期等。</p>
</li>
</ol>
<p>需要注意的是，这是一条理想的时间线，每种浏览器的具体细节实现可能不一样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面的分析，我们可以总结一下。当浏览器遇到<code>&lt;script&gt;</code>脚本时：</p>
<ol>
<li><p>同步脚本<code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br> 没有<code>defer</code>或<code>async</code>，浏览器会立即加载并执行指定的脚本，<code>立即</code>指的是在渲染该<code>&lt;script&gt;</code>标签之下的文档元素之前，也就是说文档解析器会暂停，浏览器读到就加载并执行。</p>
</li>
<li><p>异步脚本<code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br> 有<code>async</code>，加载和渲染后续文档元素的过程和<code>script.js</code>的加载与执行并行进行（异步）。</p>
</li>
<li><p>延迟脚本<code>&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br> 有<code>defer</code>，加载后续文档元素的过程和<code>script.js</code>的加载并行进行（异步），但是<code>script.js</code>的执行要在所有元素解析完成（<code>document.readyState</code>属性变成<code>interactive</code>）之后，<code>DOMContentLoaded</code>事件触发之前完成。</p>
</li>
</ol>
<p>最后用一张图来总结：<br><img src="../images/23/1.png" alt="image"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/JavaScript/">JavaScript</a><a href="/tags/浏览器/">浏览器</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/08/23-使用原生JS实现dialog组件/"><span>(WIP)23.使用原生JS实现dialog组件</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/08/23-使用原生JS实现dialog组件/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-08T08:51:45.000Z">
          2018-11-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当时觉得这个蛮简单的，只要写好html、样式，然后append进document.body就行了。但真正写起来时才发现没那么简单。比如原生的appendChild需要参数为Node，而你现在是需要把HTML的字符串转化为Node。这要怎么做呢？</p>
<h2 id="String转化为DOM"><a href="#String转化为DOM" class="headerlink" title="String转化为DOM"></a>String转化为DOM</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/WIP/">WIP</a><a href="/tags/JavaScript/">JavaScript</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 Xiaolong Lin
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>