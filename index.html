<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>One Pieces</title>

  
  <meta name="author" content="Xiaolong Lin">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="One Pieces"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="One Pieces" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">One Pieces</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/14/24-Promises-A-规范/"><span>24.Promises/A+ 规范</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/14/24-Promises-A-规范/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-14T09:13:13.000Z">
          2018-11-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>(原文 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promises/A+</a>)</p>
<p>一个具有互操作性的 JavaScript promises 的开源标准。</p>
<p>一个 promise 代表着异步操作的最终结果。与 promise 进行交互的主要方式是通过then方法，该方法注册回调来接收 promise 的最终值或 promise 无法完成（失败）的原因。</p>
<p>该规范详细说明了then方法的行为，它提供了一个可互操作的标准，使所有符合 Promises/A+ 规范的 promise 依据该标准来实现。因此，该规范应该被认为是非常稳定（stable）的。即使 Promises/A+ 组织偶尔会修改该规范，只是为了解决新发现的极端问题而加入一些比较小的向后兼容的更改，但只有经过仔细考虑，讨论和测试后，我们才会整合大的或向后不兼容的改动。</p>
<p>Promises/A+ 阐明了早期的 Promises/A 提案的行为条款，并将其扩展，使其覆盖到现实中的例子，且忽略了未确定和有问题的部分。</p>
<p>最后，该 Promises/A+ 规范的核心并不是规定如何新建（create），完成（fulfill），拒绝（reject） promises，而是专注于提供一个可互操作的then方法。相关规范的后续工作可能会涉及到这些主题。</p>
<h3 id="1-术语"><a href="#1-术语" class="headerlink" title="1. 术语"></a>1. 术语</h3><p>1.1 “promise” 是一个具有符合该规范规定行为的then方法的对象或函数</p>
<p>1.2 “thenable” 是一个定义了then方法的对象或函数。</p>
<p>1.3 <code>值</code>（”value”） 是任意合法的JavaScript的值（包括<code>undefined</code>，一个 thenable，或者一个 promise）。</p>
<p>1.4 <code>异常</code>（”exception”） 是 一个使用了<code>throw</code>语法抛出的值</p>
<p>1.5 <code>原因</code>（”reason”） 是一个表示为什么 promise 被拒绝的原因。</p>
<h3 id="2-要求"><a href="#2-要求" class="headerlink" title="2. 要求"></a>2. 要求</h3><h4 id="2-1-Promise状态"><a href="#2-1-Promise状态" class="headerlink" title="2.1 Promise状态"></a>2.1 Promise状态</h4><p>一个 Promise 必须处在以下三种状态中的一个：<code>pending</code>，<code>fulfilled</code>，<code>rejected</code>。</p>
<ul>
<li><p>2.1.1 当状态为<code>pending</code>时：  </p>
<ul>
<li>2.1.1.1 可以转换到<code>fulfilled</code>或者<code>rejected</code>。</li>
</ul>
</li>
<li><p>2.1.2 当状态为<code>fulfilled</code>时：</p>
<ul>
<li>2.1.2.1 不能转换为其它状态。</li>
<li>2.1.2.2 必须有一个不可修改的<code>值(value)</code>。</li>
</ul>
</li>
<li><p>2.1.3 当状态为<code>rejected</code>时：</p>
<ul>
<li>2.1.3.1 不能转换为其它状态。</li>
<li>2.1.3.2 必须有一个不可修改的<code>原因(reason)</code>。</li>
</ul>
</li>
</ul>
<p>上文的“不可修改”的含义是一旦创建就不能被修改（类似<code>===</code>），但并不意味着这个不可变性是深嵌套的。</p>
<h4 id="2-2-then方法"><a href="#2-2-then方法" class="headerlink" title="2.2 then方法"></a>2.2 <code>then</code>方法</h4><p>一个 promise 必须提供一个<code>then</code>方法去获取它当前或最终的<code>值</code>或<code>原因</code>。</p>
<p>一个 promise 的<code>then</code>方法接收两个参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>2.2.1 <code>onFulfilled</code>和<code>onRejected</code>都是可选参数：</p>
<ul>
<li>2.2.1.1 如果<code>onFulfilled</code>不是函数，则必须忽略它。</li>
<li>2.2.1.1 如果<code>onRejected</code>不是函数，则必须忽略它。</li>
</ul>
</li>
<li><p>2.2.2 如果<code>onFulfilled</code>是函数：</p>
<ul>
<li>2.2.2.1 则必须在 promise 状态转换为<code>fulfilled</code>之后调用它，且它的第一个参数为 promise 的<code>值</code>。</li>
<li>2.2.2.2 不能在 promise 状态转换为<code>fulfilled</code>之前调用它。</li>
<li>2.2.2.2 不能多次调用它。</li>
</ul>
</li>
<li><p>2.2.3 如果<code>onRejected</code>是函数：</p>
<ul>
<li>2.2.3.1 则必须在 promise 状态转换为<code>rejected</code>之后调用它，且它的第一个参数为 promise 的<code>原因</code>。</li>
<li>2.2.3.2 不能在 promise 状态转换为<code>rejected</code>之前调用它。</li>
<li>2.2.3.2 不能多次调用它。</li>
</ul>
</li>
<li><p>2.2.4 在执行上下文堆栈中仅包含平台代码<a href="#3-注释">[3.1]</a>之前，不能调用<code>onFulfilled</code>或<code>onRejected</code>。</p>
</li>
<li><p>2.2.5 <code>onFulfilled</code>和<code>onRejected</code>必须作为函数被调用（即没有<code>this</code>值）。<a href="#3-注释">[3.2]</a></p>
</li>
<li><p>2.2.6 同一个 promise 上的<code>then</code>可以被多次调用。</p>
<ul>
<li>2.2.6.1 如果/当 promise 为<code>fulfilled</code>时，所有相应的<code>onFulfilled</code>回调必须按其原本的调用顺序执行。</li>
<li>2.2.6.1 如果/当 promise 为<code>onRejected</code>时，所有相应的<code>onRejected</code>回调必须按其原本的调用顺序执行。</li>
</ul>
</li>
<li><p>2.2.7 <code>then</code>必须返回一个 promise。<a href="#3-注释">[3.3]</a></p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>
<ul>
<li>2.2.7.1 如果<code>onFulfilled</code>或<code>onRejected</code>返回一个<code>值</code>x，则运行 Promise 解析器（Promise Resolution Procedure）<code>[[Resolve]](promise2, x)</code>。</li>
<li>2.2.7.2 如果<code>onFulfilled</code>或<code>onRejected</code>返回一个<code>异常（exception）</code>e，则 promise2 必须以e为<code>原因</code>被拒绝。</li>
<li>2.2.7.3 如果<code>onFulfilled</code>不是函数且 promise1 为<code>fulfilled</code>，promise2 必须以与 promise1 相同的<code>值</code>被完成。</li>
<li>2.2.7.3 如果<code>onRejected</code>不是函数且 promise1 为<code>rejected</code>，promise2 必须以与 promise1 相同的<code>原因</code>被拒绝。</li>
</ul>
</li>
</ul>
<h4 id="2-3-Promise解析器"><a href="#2-3-Promise解析器" class="headerlink" title="2.3 Promise解析器"></a>2.3 Promise解析器</h4><p>Promise 解析器（promise resolution procedure）是一个抽象操作，它将 promise 和<code>值</code>作为输入，我们将其表示为<code>[[Resolve]](promise, x)</code>。如果<code>x</code>是<code>thenable</code>，它会使 promise 采用<code>x</code>的状态，假设<code>x</code>的行为至少有点像 promise。否则，它将以<code>x</code>为<code>值</code>完成 promise。</p>
<p>对<code>thenable</code>的这种处理使得 promise 具有互操作性，只要它们暴露出一个符合 Promises/A+ 规范的<code>then</code>方法。它还允许符合 Promises/A+ 规范的实现使用合理的<code>then</code>方法与“同化”不一致的实现。</p>
<p>为了运行<code>[[Resolve]](promise, x)</code>，需要实现以下几点：</p>
<ul>
<li>2.3.1 如果 promise 和<code>x</code>引用了同个对象，则用<code>TypeError</code>作为<code>原因</code>去拒绝 promise。</li>
<li><p>2.3.2 如果<code>x</code>是 promise，则采用它的状态：<a href="#3-注释">[3.4]</a></p>
<ul>
<li>2.3.2.1 如果<code>x</code>状态为<code>pending</code>，promise 必须保持<code>pending</code>直到<code>x</code>被完成或被拒绝。</li>
<li>2.3.2.2 如果/当<code>x</code>为<code>fulfilled</code>，用相同的<code>值</code>去完成 promise。</li>
<li>2.3.2.3 如果/当<code>x</code>为<code>rejected</code>，用相同的<code>原因</code>去拒绝 promise。</li>
</ul>
</li>
<li><p>2.3.3 否则，如果<code>x</code>是一个对象或函数，</p>
<ul>
<li>2.3.3.1 让<code>then</code>等于<code>x.then</code>。<a href="#3-注释">[3.5]</a></li>
<li>2.3.3.2 如果检测到属性<code>x.then</code>会导致抛出异常<code>e</code>，则用<code>e</code>作为<code>原因</code>去拒绝 promise。</li>
<li>2.3.3.3 如果<code>then</code>是函数（译者注，也就是<code>x</code>为<code>thenable</code>），则将<code>x</code>作为<code>this</code>调用它，第一个参数为<code>resolvePromise</code>，第二个参数为<code>rejectPromise</code>，其中：<ul>
<li>2.3.3.3.1 如果/当<code>resolvePromise</code>被调用且参数为<code>y</code>时，执行<code>[[Resolve]](promise, y)</code>。</li>
<li>2.3.3.3.2 如果/当<code>rejectPromise</code>被调用且参数为<code>r</code>时，则以<code>r</code>为<code>原因</code>拒绝 promise。</li>
<li>2.3.3.3.3 如果<code>resolvePromise</code>和<code>rejectPromise</code>都被调用，或者对同一个参数进行多次调用时，则处理第一次调用，且忽略后续调用。</li>
<li>2.3.3.3.4 如果调用<code>then</code>时抛出一个异常<code>e</code>，<ul>
<li>2.3.3.3.4.1 如果已调用<code>resolvePromise</code>或<code>rejectPromise</code>，请忽略它。</li>
<li>2.3.3.3.4.2 否则，以<code>e</code>作为<code>原因</code>拒绝 promise。</li>
</ul>
</li>
</ul>
</li>
<li>2.3.3.4 如果<code>then</code>不是函数，则以<code>x</code>作为<code>值</code>完成 promise。</li>
</ul>
</li>
<li>2.3.4 如果<code>x</code>不是一个对象或函数，则以<code>x</code>作为<code>值</code>完成 promise。</li>
</ul>
<p>如果使用了在<code>thenable</code>循环链（<code>thenable</code>的<code>then</code>是<code>thenable</code>）上的<code>thenable</code>去解决 promise，那么<code>[[Resolve]](promise, thenable)</code>的递归性质最终会导致<code>[[Resolve]](promise, thenable)</code>再次被调用，上述算法将导致无限递归。我们鼓励（但不是必需）对此类递归逻辑进行检测，如果有，则以一个信息性的<code>TypeError</code>作为<code>原因</code>去拒绝 promise。<a href="#3-注释">[3.6]</a></p>
<h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h3><ul>
<li><p>3.1 这里的<code>平台代码</code>特指执行引擎，运行环境和 promise 实现的代码。在实践中，这个要求确保了<code>onFulfilled</code>和<code>onRejected</code>的异步执行，是在调用<code>then</code>的事件轮训时间片之后，且调用栈为空。这可以使用诸如 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#timers" target="_blank" rel="noopener">setTimeout</a> 或 <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html#processingmodel" target="_blank" rel="noopener">setImmediate</a> 之类的<code>宏任务</code>机制，或者 <a href="https://dom.spec.whatwg.org/#interface-mutationobserver" target="_blank" rel="noopener">MutationObserver</a> 或 <a href="https://nodejs.org/api/process.html#process_process_nexttick_callback" target="_blank" rel="noopener">process.nextTick</a> 之类的<code>微任务</code>机制来实现。由于 promise 的实现代码被认为是平台代码，因此它本身可能包含一个任务调度队列或<code>trampoline（跳板）</code>来调用处理程序。</p>
</li>
<li><p>3.2 也就是说，在严格模式（<code>use strict</code>）下，<code>this</code>将是<code>undefined</code>；在松散模式（<code>sloppy mode</code>）下，<code>this</code>将会是全局对象。</p>
</li>
<li><p>3.3 如果具体实现满足所有要求，我们可以允许<code>promise2 === promise1</code>。每个具体实现都应该说明它是否可以支持<code>promise2 === promise1</code>，以及在什么条件下支持。</p>
</li>
<li><p>3.4 一般来说，如果它来自于当前的具体实现，那<code>x</code>可以被认为是一个真正的 promise。这个条款允许我们使用特定的实现手段，让我们可以去获取被认为符合规范（译者注，比如一个自行实现了<code>then</code>方法的对象）的 promises 的状态。</p>
</li>
<li><p>3.5 该步骤需先存储<code>x.then</code>的引用，后续测试和调用的都是该引用，这样可以避免多次访问<code>x.then</code>属性。这些预防措施对于保证可访问属性的一致性非常重要。可访问属性的值可能会在检索之间发生变化。</p>
</li>
<li><p>3.6 该实现不应该对<code>thenable</code>链的深度设置某个限制值，假设超过这个限制值之后会发生无限递归。只有真正的循环才会引起一个<code>TypeError</code>错误；如果是不同的<code>thenable</code>组成一个无穷的调用链，那么一直递归其实是正确的行为。</p>
</li>
</ul>
<p>在法律允许的范围内，Promises/A+ 组织已放弃 Promises/A+ Promise 规范的所有版权，以及相关或相近的权利。该声明发表于：美国。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Promise/">Promise</a><a href="/tags/规范/">规范</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/09/23-客户端JavaScript执行的时间线/"><span>23.浏览器JavaScript执行的时间线</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/09/23-客户端JavaScript执行的时间线/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-09T07:29:40.000Z">
          2018-11-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道浏览器的渲染线程和脚本线程是互斥的，JavaScript会阻塞浏览器HTML解析器，这也是为什么长时间的脚本运行可能会导致页面失去响应。因此，我们通常会把<code>&lt;script&gt;</code>放在<code>&lt;/body&gt;</code>之前，来保证非脚本的其他一切元素能尽快地得到加载和解析。<br>然而，我们可以通过设置<code>&lt;scirpt&gt;</code>的<code>async</code>和<code>defer</code>来改变<code>&lt;script&gt;</code>的加载和执行顺序。在说这具体是怎样之前,我们先介绍一下浏览器JavaScript执行的时间线。</p>
<h2 id="JavaScript的执行"><a href="#JavaScript的执行" class="headerlink" title="JavaScript的执行"></a>JavaScript的执行</h2><ol>
<li><p>浏览器创建<code>Document</code>对象，并且开始解析Web页面，解析HTML元素和它们的文本内容后，会添加Element对象和Text节点到文档中。在这个阶段document.readystate属性的值是<code>loading</code>。</p>
</li>
<li><p>当HTML解析器遇到没有<code>async</code>和<code>defer</code>属性的<code>&lt;script&gt;</code>元素时，它把这些元素添加到文档中，然后执行行内或者外部脚步。这些脚本会同步执行，并且在脚本下载（如果需要）和执行时，HTML解析器会暂停。这样脚本就可以用<code>document.write()</code>来把文本插入到输入流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单定义函数和注册后面使用的注册事件处理程序，但它们可以遍历和操作文档树，因为在它们执行时已经存在了。这样，同步脚本可以看到它自己的<code>&lt;script&gt;</code>元素和它们之前的文档内容。</p>
</li>
<li><p>当解析器遇到设置了<code>async</code>属性的<code>&lt;script&gt;</code>元素时，它开始下载脚本文本，并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器没有停下来等它下载。异步脚本禁止使用<code>document.write()</code>方法。它们可以看到自己的<code>&lt;script&gt;</code>元素和它之前的所有文档元素，并且可能或干脆不访问其他的文档内容。</p>
</li>
<li><p>当文档完成解析，<code>document.readyState</code>属性变成<code>interactive</code>。</p>
</li>
<li><p>所有有<code>defer</code>属性的脚本，会按它们在文档里的出现顺序执行。异步脚本可能也会在这个时间执行。延迟脚本能访问完整的文档树，禁止使用<code>document.write()</code>方法。</p>
</li>
<li><p>浏览器在<code>Document</code>对象上触发<code>DOMContentLoaded</code>事件。这标志着程序执行从同步脚本执行阶段转换到了异步事件驱动阶段。但要注意，这时可能还有异步脚本没有执行完成。</p>
</li>
<li><p>这时，文档已经完全解析完成，但是浏览器可能还在等待其他内容载入，比如图片。当所有这些内容完成载入时，并且所有异步脚本完成载入和执行，<code>document.readyState</code>属性改变为<code>complete</code>，浏览器触发<code>Window</code>对象上的<code>load</code>事件。</p>
</li>
<li><p>从此刻起，会调用异步事件，以异步响应用户输入事件、网络事件、计时器过期等。</p>
</li>
</ol>
<p>需要注意的是，这是一条理想的时间线，每种浏览器的具体细节实现可能不一样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面的分析，我们可以总结一下。当浏览器遇到<code>&lt;script&gt;</code>脚本时：</p>
<ol>
<li><p>同步脚本<code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br> 没有<code>defer</code>或<code>async</code>，浏览器会立即加载并执行指定的脚本，<code>立即</code>指的是在渲染该<code>&lt;script&gt;</code>标签之下的文档元素之前，也就是说文档解析器会暂停，浏览器读到就加载并执行。</p>
</li>
<li><p>异步脚本<code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br> 有<code>async</code>，加载和渲染后续文档元素的过程和<code>script.js</code>的加载与执行并行进行（异步）。</p>
</li>
<li><p>延迟脚本<code>&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br> 有<code>defer</code>，加载后续文档元素的过程和<code>script.js</code>的加载并行进行（异步），但是<code>script.js</code>的执行要在所有元素解析完成（<code>document.readyState</code>属性变成<code>interactive</code>）之后，<code>DOMContentLoaded</code>事件触发之前完成。</p>
</li>
</ol>
<p>最后用一张图来总结：<br><img src="../images/23/1.png" alt="image"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/JavaScript/">JavaScript</a><a href="/tags/浏览器/">浏览器</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/08/23-使用原生JS实现dialog组件/"><span>(WIP)23.使用原生JS实现dialog组件</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/08/23-使用原生JS实现dialog组件/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-08T08:51:45.000Z">
          2018-11-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当时觉得这个蛮简单的，只要写好html、样式，然后append进document.body就行了。但真正写起来时才发现没那么简单。比如原生的appendChild需要参数为Node，而你现在是需要把HTML的字符串转化为Node。这要怎么做呢？</p>
<h2 id="String转化为DOM"><a href="#String转化为DOM" class="headerlink" title="String转化为DOM"></a>String转化为DOM</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/WIP/">WIP</a><a href="/tags/JavaScript/">JavaScript</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/08/22-Webpack提示Invalid-Host-Header/"><span>22-Webpack提示Invalid Host Header</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/08/22-Webpack提示Invalid-Host-Header/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-08T07:49:09.000Z">
          2018-11-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>用<a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener"><code>vue-cli 3</code></a>新建项目，将自定义域名映射到localhost，这时用自定义域名访问项目，webpack-dev-server返回了Invalid Host Header，而使用localhost或127.0.0.1则没报错。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>网上查了一些资料，发现这是因为webpack-dev-server在<a href="https://github.com/webpack/webpack-dev-server/releases/tag/v2.4.3" target="_blank" rel="noopener"><code>2.4.3</code></a>和<a href="https://github.com/webpack/webpack-dev-server/releases/tag/v1.16.4" target="_blank" rel="noopener"><code>1.16.4</code></a>这两个版本增加了security fix。这个fix增加了对<code>Host</code> header 的检验，来防止恶意网站访问你的<code>assets</code>。同时<code>webpack-dev-middleware</code>的<code>1.10.2</code>也增加了这个修改。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>考虑到这个fix可能会break项目启动，webpack-dev-server提供了几个解决方案</p>
<ul>
<li>新增<code>disableHostCheck</code>参数，为<code>true</code>时host check失效</li>
<li>执行webpack-dev-server时手动添加<code>--public</code>参数，值为授权的host</li>
</ul>
<p>在后续的版本里，webpack-dev-server也增加了相关的一些参数，比如<code>allowedHosts</code>(<a href="https://github.com/webpack/webpack-dev-server/releases/tag/v2.5.0" target="_blank" rel="noopener"><code>2.5.0</code></a>)。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://tonghuashuo.github.io/blog/webpack-dev-server-invalid-host-header.html" target="_blank" rel="noopener">解决 Webpack “Invalid Host Header”</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/webpack/">webpack</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/25/21-docker-jenkins自动部署/"><span>21.docker+jenkins自动部署前端代码</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/25/21-docker-jenkins自动部署/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-25T15:12:50.000Z">
          2018-09-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>服务器为腾讯云Ubuntu</p>
</blockquote>
<h3 id="一、安装Docker"><a href="#一、安装Docker" class="headerlink" title="一、安装Docker"></a>一、安装Docker</h3><ol>
<li><p>更新<code>apt</code>包</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装最新版本的Docker</p>
<p> 中文版教程： <a href="https://cloud.tencent.com/developer/article/1167995" target="_blank" rel="noopener">如何在Ubuntu上安装使用Docker</a></p>
<p> 不过最好还是看英文版：<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-using-the-repository" target="_blank" rel="noopener">install-using-the-repository</a></p>
<p> 或者使用官方Ubuntu存储库中提供的Docker安装包，但是可能不是最新的版本。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用内置安装</span></span><br><span class="line">$ sudo apt-get install docker.io</span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">$ sudo apt-get purge docker.io</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="二、安装Jenkins"><a href="#二、安装Jenkins" class="headerlink" title="二、安装Jenkins"></a>二、安装Jenkins</h3><p>使用docker安装Jenkins非常方便，只需要执行下面命令即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name devops-jenkins --user=root -p 8080:8080 -p 50000:50000 -v /opt/data/jenkins_home:/var/jenkins_home -d jenkins/jenkins:lts</span><br></pre></td></tr></table></figure></p>
<p>更多定制参数可以参考 <a href="https://github.com/jenkinsci/docker" target="_blank" rel="noopener">https://github.com/jenkinsci/docker</a></p>
<h3 id="三、配置Jenkins"><a href="#三、配置Jenkins" class="headerlink" title="三、配置Jenkins"></a>三、配置Jenkins</h3><p>启动Jenkins之后，在浏览器输入http://部署jenkins主机IP:端口 (8080)<br><img src="../images/21/1.png" alt="image"></p>
<p>根据提示，从输入administrator password 或者可以通过启动日志<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs devops-jenkins</span><br></pre></td></tr></table></figure></p>
<p>查看这个password<br><img src="../images/21/2.png" alt="image"></p>
<p>选择安装插件方式，这里默认第一个。<br><!-- ![image](../images/21/3.png) --></p>
<p>进入插件安装界面，连网等待插件安装。</p>
<p>安装完插件后，进入创建管理员界面。<br><img src="../images/21/5.png" alt="image"></p>
<p>输入管理员信息后，点击Continue as admin。</p>
<p><img src="../images/21/6.png" alt="image"><br>保存Jenkins URL后Jenkins就安装完毕了。</p>
<h3 id="四、自动化流程"><a href="#四、自动化流程" class="headerlink" title="四、自动化流程"></a>四、自动化流程</h3><p>在正式使用Jenkins前，我们先来看一下自动部署的流程，具体如下：</p>
<ul>
<li>编写修改代码，并提交代码到代码仓库（git）</li>
<li>Jenkins自动检测到仓库代码更新了，从仓库拉去最新代码</li>
<li>Jenkins自动编译</li>
<li></li>
</ul>
<p>Jenkins之所以流行，是因为它的高灵活性和高易用性。这得益于它的插件机制，只需安装对应功能的插件，即可使它适应各种业务场景。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/23/20-使用wafer2-quickstart-nodejs-master小程序模板本地开发踩坑指南/"><span>20.使用wafer2-quickstart-nodejs-master小程序模板本地开发踩坑指南</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/23/20-使用wafer2-quickstart-nodejs-master小程序模板本地开发踩坑指南/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-23T14:31:07.000Z">
          2018-09-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="使用wafer2-quickstart-nodejs-master小程序模板本地开发踩坑指南"><a href="#使用wafer2-quickstart-nodejs-master小程序模板本地开发踩坑指南" class="headerlink" title="使用wafer2-quickstart-nodejs-master小程序模板本地开发踩坑指南"></a>使用wafer2-quickstart-nodejs-master小程序模板本地开发踩坑指南</h2><h4 id="一、本地调试获取用户失败"><a href="#一、本地调试获取用户失败" class="headerlink" title="一、本地调试获取用户失败"></a>一、本地调试获取用户失败</h4><p>在使用微信官方提供的 <a href="https://github.com/tencentyun/wafer2-quickstart-nodejs" target="_blank" rel="noopener">wafer2-quickstart-nodejs-master</a> 模板开发小程序时，除了可以连接腾讯云提供的开发环境，还可以直接在本地起服务进行调试。具体操作可参考<a href="https://github.com/tencentyun/wafer2-startup/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98#%E6%9C%AC%E5%9C%B0%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">本地如何搭建开发环境</a>。</p>
<p>但按照文档上的步骤操作，会报“ERR_REQUEST_PARAM”的错误。报这个错误的原因是，代码默认使用了腾讯云代理登录小程序。</p>
<p>打开<code>server/config.js</code>，将<code>useQcloudLogin</code>选项修改为false，同时还需要填上小程序的<code>appSecret</code>。因为<code>useQcloudLogin</code>为<code>true</code>时，<code>SDK</code>会通过与小程序关联的腾讯云账号获取到<code>appSecret</code>，授权通过后，再获取用户信息。否则为<code>false</code>时，则需要填写<code>appSecret</code>。</p>
<p>这样修改后，再次请求，就能获取到用户信息了。</p>
<h4 id="二、第一次获取用户信息"><a href="#二、第一次获取用户信息" class="headerlink" title="二、第一次获取用户信息"></a>二、第一次获取用户信息</h4><p>在模板中，<code>wafer2-client-sdk</code>封装了一下方法让我们使用。比如我们可以使用<code>request</code>发送请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qcloud = <span class="built_in">require</span>(<span class="string">'../vendor/wafer2-client-sdk/index'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 请求A</span></span><br><span class="line">qcloud.request(&#123;</span><br><span class="line">    url,</span><br><span class="line">   	data,</span><br><span class="line">    method,</span><br><span class="line">    login: <span class="literal">false</span>,</span><br><span class="line">    success(result) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    fail(error) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过参数<code>login</code>可以控制发送该请求<code>A</code>之前，是否先发送登录请求。如果请求<code>A</code>需要用户信息，则<code>login</code>需为<code>true</code>，否则后端的ctx.state.$wxInfo是没有用户信息的。但是在用户第一次登录之前（<code>cSessioninfo</code>表里没有该用户数据），<code>qcloud.request({ login: true })</code>会报错，返回<code>Cannot read property &#39;user_info&#39; of undefined</code>错误。</p>
<p>这是因为<code>qcloud.request</code>只使用了<code>loginWithCode</code>来登录。这个方法会在<code>Header</code>加上<code>X-WX-Code</code>（其实就是<code>cSessioninfo</code>表里的<code>skey</code>）。后端通过这个code去获取对应用户的信息。但因为表里根本没有这个用户的记录，所以报了上面的错误。</p>
<p>要怎么解决这个问题？其实模板中有类似的调用。打开<code>client/page/pages/index/index.js</code>，答案就在<code>bindGetUserInfo</code>里。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 先获取session</span></span><br><span class="line"><span class="keyword">const</span> session = qcloud.Session.get()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 如果session不为空，则说明用户已经登录过，即数据库里有该用户记录，则使用qcloud.loginWithCode</span></span><br><span class="line"><span class="comment">// 2. 如果session为空，则说明用户第一次登录，则调用qcloud.login，将用户信息写入数据库</span></span><br><span class="line"><span class="keyword">if</span> (session) &#123;</span><br><span class="line">    <span class="comment">// 第二次登录</span></span><br><span class="line">    <span class="comment">// 或者本地已经有登录态</span></span><br><span class="line">    <span class="comment">// 可使用本函数更新登录态</span></span><br><span class="line">    qcloud.loginWithCode(&#123;</span><br><span class="line">        success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 首次登录</span></span><br><span class="line">    qcloud.login(&#123;</span><br><span class="line">        success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>qcloud.login</code>会在<code>Header</code>增加三个字段，<code>X-WX-Code</code>、<code>X-WX-Encrypted-Data</code>、<code>X-WX-IV</code>，然后后端会在表里插入该用户的信息。</p>
<p>所以我们需要将这段逻辑加到<code>qcloud.request</code>里。<code>qcloud.request</code>里有个<code>doRequestWithLogin</code>方法，是发送登录逻辑的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录后再请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doRequestWithLogin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    loginLib.loginWithCode(&#123; <span class="attr">success</span>: doRequest, <span class="attr">fail</span>: callFail &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将其修改为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录后再请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doRequestWithLogin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> session = Session.get()</span><br><span class="line">    <span class="keyword">if</span> (session) &#123;</span><br><span class="line">        loginLib.loginWithCode(&#123; <span class="attr">success</span>: doRequest, <span class="attr">fail</span>: callFail &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        loginLib.login(&#123; <span class="attr">success</span>: doRequest, <span class="attr">fail</span>: callFail &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Done！大功告成，再次发送请求成功！</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/微信小程序/">微信小程序</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/21/22-CommonJS模块规范/"><span>(WIP)22.CommonJS模块规范</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/21/22-CommonJS模块规范/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-21T11:35:17.000Z">
          2018-09-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>对于JavaScript自身而言，它的规范是薄弱的。</p>
<ul>
<li>没有模块系统。</li>
<li>标准库较少。</li>
<li>没有标准接口。</li>
<li>缺乏包管理系统。</li>
</ul>
<p>这使得JavaScript难以达到像Python、Ruby和Java一样，具备开发大型应用的基础能力。CommonJS规范的提出，主要是为了弥补JavaScript没有标准的缺陷。</p>
<h3 id="CommonJS的模块规范"><a href="#CommonJS的模块规范" class="headerlink" title="CommonJS的模块规范"></a>CommonJS的模块规范</h3><p>CommonJS对模块的定义很简单，主要分为模块引用、模块定义和模块标识3个部分。</p>
<ol>
<li>模块引用</li>
</ol>
<p>我们可以通过<code>require()</code>方法，接受模块标识，来引入一个模块的API到当前上下文中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>模块定义</li>
</ol>
<p>在Node中，一个文件就是一个模块。在模块中，上下文提供了exports对象用于到处当前模块的方法或变量，而且它是唯一导出的出口。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/WIP/">WIP</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/09/21-贝塞尔曲线原理简介/"><span>(WIP)21-贝塞尔曲线原理简介</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/09/21-贝塞尔曲线原理简介/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-09T06:08:04.000Z">
          2018-08-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在CSS动画中，我们会经常听到贝塞尔曲线。</p>
<p>贝塞尔曲线，是应用于二维图形应用程序的数学曲线，一般的矢量图形软件通过它来精确地画出曲线。<br>最初由法国工程师皮埃尔·贝济埃（Pierre Bézier）于1962年所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计，因此以他的名字命名。</p>
<p>我们先来看看下面一条曲线。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/WIP/">WIP</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/27/19-http2简介/"><span>19.http2简介</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/27/19-http2简介/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-27T06:17:48.000Z">
          2018-03-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>转自 <a href="https://developers.google.com/web/fundamentals/performance/http2/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/http2/</a></p>
<p><img src="../images/19/http2.png" alt="image"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/http/">http</a><a href="/tags/网络/">网络</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/27/18-http头部如何对缓存控制/"><span>18.http头部如何对缓存控制</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/27/18-http头部如何对缓存控制/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-27T05:27:23.000Z">
          2018-03-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>使用缓存的目的就是在于减少计算、IO、网络等时间，可以快速的返回，特别是流量比较大的时候，可以节约很多服务器带宽和压力。</p>
<p>一个请求从缓存的方面来说，有三个过程。</p>
<h3 id="本地检查缓存是否过期"><a href="#本地检查缓存是否过期" class="headerlink" title="本地检查缓存是否过期"></a>本地检查缓存是否过期</h3><p><code>Expires</code>，http1.0版本定义的response头部，定义过期时间，如果本地时间发现超过过期时间，就会向服务器请求，进行文件新鲜度检测。<strong>但是会有一个问题，就是本地的操作系统时间可能偏差比较大，导致缓存时间过长或者永远都缓存不了。</strong></p>
<p><code>Cache-control: max-age=xxx</code>，http1.1版本定义的response头部，就是为了解决操作系统时间与服务器时间相差太大的问题。文件缓存存活时间，请求完毕的时候，会记录本地的时间。再次请求的时候，此时时间减去最初记录时间，如果时间大于max-age，就会进行文件新鲜度检测。</p>
<ul>
<li><p>如果浏览器使用本地缓存，通过chrome调试工具，可以看到，状态是200，size是<code>from cache</code>。这个时候是没有http请求的。</p>
</li>
<li><p>如果缓存不存在或者没有定义这两个头部，直接进行下一步新鲜度检测。</p>
</li>
<li><p>如果两个都定义的话，<code>Expires</code>无效。</p>
</li>
<li><p>防止浏览器缓存，我们需要把两个头部都设置为0。</p>
</li>
</ul>
<h3 id="服务器检测文件新鲜度"><a href="#服务器检测文件新鲜度" class="headerlink" title="服务器检测文件新鲜度"></a>服务器检测文件新鲜度</h3><p>本地缓存过期，缓存和服务器文件可能一样，也有可能不一样。如果一样的话，就没有必要返回内容。如果不一样，就返回内容，就相当于一次新的请求。</p>
<p>怎么判断文件是否一致呢？现在的做法是通过文件生成时间或者文件进行MD5值计算。</p>
<p><code>Last-Modified</code>，文件生成时间或者最后修改时间。下一次请求的头部，添加<code>If-Modified-Since</code>，值是上次response头部的<code>Last-Modified</code>值，和服务器进行对比，如果一样的话，直接返回304，数据内容为空。<strong>【这里也会存在一个问题，如果文件定期更新，但是文件内容不更新，岂不是白白耗费流量】</strong></p>
<p><code>Etag</code>，服务器端对文件计算出来的一个值。下一次请求的头部，添加<code>If-None-Match</code>，和服务器进行对比，如果一样的话，直接返回304，数据内容为空。</p>
<h3 id="服务器返回数字内容"><a href="#服务器返回数字内容" class="headerlink" title="服务器返回数字内容"></a>服务器返回数字内容</h3><p>相当于一次新的请求，状态是200.</p>
<p>通过输出4个头部，来控制缓存，减少压力，不仅可以节省服务器和宽带资源，对用户的体验提升也是非常有帮助的。</p>
<p>整体上可以看到可能出现的情况。200（<code>from cache</code>，无请求），304（仅仅是头部交换，没有response body返回），200（一次完整的请求，包含response body）。</p>
<p><img src="../images/18/flow.png" alt="image"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/http/">http</a><a href="/tags/缓存/">缓存</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 Xiaolong Lin
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>