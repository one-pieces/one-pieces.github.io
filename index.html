<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>One Pieces</title>

  
  <meta name="author" content="Xiaolong Lin">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="One Pieces"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="One Pieces" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">One Pieces</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/02/Kruskal’s-最小生成树算法-贪婪算法-2/"><span>Kruskal’s 最小生成树算法 | 贪婪算法-2</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/02/Kruskal’s-最小生成树算法-贪婪算法-2/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-02T11:21:56.000Z">
          2019-07-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>原文：<a href="https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/" target="_blank" rel="noopener">Kruskal’s Minimum Spanning Tree Algorithm | Greedy Algo-2</a></p>
<p><em>什么是最小生成树？</em><br>给定一个连通的无向图，该图的生成树是一个子图，它是一棵将所有顶点连接在一起的树。单个图可以有许多不同的生成树。一个加权连通无向图的最小生成树（MST）或最小权重生成树是指其权重小于或等于所有其他生成树的权重。生成树的权重是树上每条边（edge）的权重的总和。</p>
<p><em>最小生成树有多少条边？</em><br>有 （V-1）条边，其中 V 是图的顶点的个数。</p>
<p><em>最小生成树有什么应用？</em><br>请看<a href="https://www.geeksforgeeks.org/applications-of-minimum-spanning-tree/" target="_blank" rel="noopener">这个</a></p>
<p>下面是使用 Kruskal’s 算法找出 MST 的步骤：</p>
<ol>
<li>按权重的非降序对所有边排序。</li>
<li>选取最小的边。检验当前生成树是否产生环（cycle），如果没有则选择，否则不选取。</li>
<li>重复步骤2 直到生成树有（V-1）条边。</li>
</ol>
<p>步骤2 可以使用联合查找算法（<a href="https://www.geeksforgeeks.org/union-find/" target="_blank" rel="noopener">Union-Find algorithm</a>）检查是否有环。我们建议先查看一下文章：<br><a href="https://www.geeksforgeeks.org/union-find/" target="_blank" rel="noopener">Union-Find Algorithm | Set 1 (Detect Cycle in a Graph)</a><br><a href="https://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/" target="_blank" rel="noopener">Union-Find Algorithm | Set 2 (Union By Rank and Path Compression)</a></p>
<p>这个算法是贪婪算法。贪婪选择的策略是选取权重最小的边，且不会使当前构建的 MST 产生环。让我们通过一个例子来理解它：看看下面的输入图。</p>
<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-0.jpg" alt=""></p>
<p>该图包括 9 个顶点和 14 个边。所以最小生成树将有（9-1）= 8 条边。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">After sorting:</span><br><span class="line">Weight   Src    Dest</span><br><span class="line">1         7      6</span><br><span class="line">2         8      2</span><br><span class="line">2         6      5</span><br><span class="line">4         0      1</span><br><span class="line">4         2      5</span><br><span class="line">6         8      6</span><br><span class="line">7         2      3</span><br><span class="line">7         7      8</span><br><span class="line">8         0      7</span><br><span class="line">8         1      2</span><br><span class="line">9         3      4</span><br><span class="line">10        5      4</span><br><span class="line">11        1      7</span><br><span class="line">14        3      5</span><br></pre></td></tr></table></figure></p>
<p>现在一步步地从排好序的数组里选取所有边。</p>
<ol>
<li>选取边 7-6：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-1.jpg" alt=""></li>
<li>选取边 8-2：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-2.jpg" alt=""></li>
<li>选取边 6-5：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-3.jpg" alt=""></li>
<li>选取边 0-1：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-4.jpg" alt=""></li>
<li>选取边 2-5：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-5.jpg" alt=""></li>
<li>选取边 8-6：由于包含此边会导致环，所以不选取它。</li>
<li>选取边 2-3：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-6.jpg" alt=""></li>
<li>选取边 7-8：由于包含此边会导致环，所以不选取它。</li>
<li>选取边 0-7：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-7.jpg" alt=""></li>
<li>选取边 1-2：由于包含此边会导致环，所以不选取它。</li>
<li>选取边 3-4：没有产生环，则包含它。<br><img src="https://www.geeksforgeeks.org/wp-content/uploads/fig8new.jpeg" alt=""></li>
</ol>
<p>直到包含的变得数目等于（V-1），算法结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有权边</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> src, dest, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连通、无向、有权图</span></span><br><span class="line">sturct Graph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// V 顶点数目，E 边数目</span></span><br><span class="line">    <span class="keyword">int</span> V, E;</span><br><span class="line">    <span class="comment">// 图中的所有边</span></span><br><span class="line">    <span class="comment">// 当图为无向图时，从 src 到 dest 还是从 dest 到 src 都只算一条边</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>* <span class="title">edge</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个有 V 个顶点和 E 条边的图</span></span><br><span class="line"><span class="function">struct Graph* <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span> V, <span class="keyword">int</span> E)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>* <span class="title">graph</span> = <span class="title">new</span> <span class="title">Graph</span>;</span></span><br><span class="line">    graph-&gt;V = V;</span><br><span class="line">    graph-&gt;E = E;</span><br><span class="line">    </span><br><span class="line">    graph-&gt;edge = <span class="keyword">new</span> Edge[E];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合查找的 subset</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">    <span class="keyword">int</span> rank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找集合中元素 i</span></span><br><span class="line"><span class="comment">// 使用路径压缩技巧</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(struct subset subsets[], <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查找根节点 root，然后使 i 的父节点为 root</span></span><br><span class="line">    <span class="comment">// 路径压缩</span></span><br><span class="line">    <span class="keyword">if</span> (subsets[i].parent != i)</span><br><span class="line">        subsets[i].parent = find(subsets, subsets[i].parent);</span><br><span class="line">    <span class="keyword">return</span> subsets[i].parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合两个集合 x 和 y</span></span><br><span class="line"><span class="comment">// 根据 rank 进行联合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(struct subset subsets[], <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xroot = find(subsets, x);</span><br><span class="line">    <span class="keyword">int</span> yroot = find(subsets, y);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 rank 较低的树附加到 rank 较高的树下</span></span><br><span class="line">    <span class="keyword">if</span> (subsets[xroot].rank &lt; subsets[yroot].rank)</span><br><span class="line">        subsets[xroot].parent = yroot;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (subsets[xroot].rank &gt; subsets[yroot].rank)</span><br><span class="line">        subsets[yroot].parent = xroot;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 如果 rank 相同，则使其中一个为 root，且其 rank 增加 1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        subsets[yroot].parent = xroot;</span><br><span class="line">        subsets[xroot].rank++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myComp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>* <span class="title">a1</span> = (<span class="title">struct</span> <span class="title">Edge</span>*)<span class="title">a</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>* <span class="title">b1</span> = (<span class="title">struct</span> <span class="title">Edge</span>*)<span class="title">b</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a1-&gt;weight &gt; b1-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KruskalMST</span><span class="params">(struct Graph* graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V = graph-&gt;V;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> <span class="title">result</span>[<span class="title">V</span>];</span></span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一步：根据权值按非降序对所有边进行排序。</span></span><br><span class="line">    <span class="comment">// 排序不能改变原本的图结构</span></span><br><span class="line">    qsort(graph-&gt;edge, graph-&gt;E, <span class="keyword">sizeof</span>(graph-&gt;edge[<span class="number">0</span>]), myComp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配用于创建 V 个元素的 subsets 的内存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subset</span> *<span class="title">subsets</span> = </span></span><br><span class="line"><span class="class">        (<span class="title">struct</span> <span class="title">subset</span>*) <span class="title">malloc</span>( <span class="title">V</span> * <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">subset</span>) );</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 初始化 V subsets 的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; ++v)</span><br><span class="line">    &#123;</span><br><span class="line">        subsets[v].parent = v;</span><br><span class="line">        subsets[v].rank = <span class="number">0</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (e &lt; V <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第二步：选取最小的边。</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> <span class="title">next_edge</span> = <span class="title">graph</span>-&gt;<span class="title">edge</span>[<span class="title">i</span>++];</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = find(subsets, next_edge.src);</span><br><span class="line">        <span class="keyword">int</span> y = find(subsets, next_edge.dest);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果选取这条边不会造成环，</span></span><br><span class="line">        <span class="comment">// 则包含它到结果数组里，然后增加结果数组的下标</span></span><br><span class="line">        <span class="keyword">if</span> (x != y)</span><br><span class="line">        &#123;</span><br><span class="line">            result[e++] = next_edge;</span><br><span class="line">            Union(subsets, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Following are the edges in the constructed MST\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d -- %d == %d\n"</span>, result[i].src, result[i].dest, result[i].weight);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 给定如下有权图</span></span><br><span class="line"><span class="comment">        10 </span></span><br><span class="line"><span class="comment">    0--------1 </span></span><br><span class="line"><span class="comment">    |  \     | </span></span><br><span class="line"><span class="comment">   6|   5\   |15 </span></span><br><span class="line"><span class="comment">    |      \ | </span></span><br><span class="line"><span class="comment">    2--------3 </span></span><br><span class="line"><span class="comment">        4       */</span></span><br><span class="line">    <span class="keyword">int</span> V = <span class="number">4</span>;  <span class="comment">// 图的顶点数目</span></span><br><span class="line">    <span class="keyword">int</span> E = <span class="number">5</span>;  <span class="comment">// 图的边数目</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>* <span class="title">graph</span> = <span class="title">createGraph</span>(<span class="title">V</span>, <span class="title">E</span>);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增边 0-1</span></span><br><span class="line">    graph-&gt;edge[<span class="number">0</span>].src = <span class="number">0</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">0</span>].dest = <span class="number">1</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">0</span>].weight = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增边 0-2</span></span><br><span class="line">    graph-&gt;edge[<span class="number">1</span>].src = <span class="number">0</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">1</span>].dest = <span class="number">2</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">1</span>].weight = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增边 0-3</span></span><br><span class="line">    graph-&gt;edge[<span class="number">1</span>].src = <span class="number">0</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">1</span>].dest = <span class="number">3</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">1</span>].weight = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增边 1-3</span></span><br><span class="line">    graph-&gt;edge[<span class="number">3</span>].src = <span class="number">1</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">3</span>].dest = <span class="number">3</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">3</span>].weight = <span class="number">15</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增边 2-3</span></span><br><span class="line">    graph-&gt;edge[<span class="number">4</span>].src = <span class="number">2</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">4</span>].dest = <span class="number">3</span>;</span><br><span class="line">    graph-&gt;edge[<span class="number">4</span>].weight = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    KruskalMST(graph);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/12/08/27-Mac安装tensorflow使用环境/"><span>27.Mac安装tensorflow使用环境</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/12/08/27-Mac安装tensorflow使用环境/" rel="bookmark">
        <time class="entry-date published" datetime="2018-12-08T07:51:34.000Z">
          2018-12-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要使用 TensorFlow 非常简单。运行 TensorFlow 需要 Python，只需安装好 Python 运行环境，通过 <code>pip</code>包管理器安装即可。</p>
<blockquote>
<p>因为最新的 TensorFlow 不支持 Python 3.7，而使用 Homebrew 安装 python 会默认安装最新版本，即3.7，因此这里不使用 Homebrew。</p>
</blockquote>
<h3 id="1-安装-Python-开发环境"><a href="#1-安装-Python-开发环境" class="headerlink" title="1. 安装 Python 开发环境"></a>1. 安装 Python 开发环境</h3><p>TensorFlow 支持 Python 2 和 Python 3，这里我们选择 Python3。</p>
<blockquote>
<p>要求 Python 3.4，3.5 或者 3.6</p>
</blockquote>
<p>先查看是否安装了 python 环境<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3 --version</span><br><span class="line">pip3 --version</span><br><span class="line">vritualenv --version</span><br></pre></td></tr></table></figure></p>
<p>如果这些包都已经安装，则可以跳过下面步骤到<a href="#2-创建虚拟环境（推荐）">步骤2</a>。否则需要安装 <a href="https://www.python.org/downloads/mac-osx/" target="_blank" rel="noopener">Python</a>，<a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="noopener">pip 包管理器</a>和 <a href="https://virtualenv.pypa.io/en/stable/" target="_blank" rel="noopener">Virtualenv</a>（用来创建隔离的 Python 环境的工具）。</p>
<p>1.1 安装 Python<br>点击 <a href="https://www.python.org/downloads/mac-osx/" target="_blank" rel="noopener">Python 下载</a>，选择对应的 <code>Python 3.6.7 - 2018-10-20</code> 安装包，下载安装到Mac即可。<br><img src="../images/27/1.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否安装成功</span></span><br><span class="line">python3 --version</span><br><span class="line">pip3 --version</span><br></pre></td></tr></table></figure>
<p>1.2 安装 vritualenv<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install -U virtualenv  # system-wide install</span><br></pre></td></tr></table></figure></p>
<h3 id="2-创建虚拟环境（推荐）"><a href="#2-创建虚拟环境（推荐）" class="headerlink" title="2. 创建虚拟环境（推荐）"></a>2. 创建虚拟环境（推荐）</h3><p>Python 虚拟环境用于将软件包的安装与系统环境进行隔离。</p>
<p>2.1 首先创建一个新的虚拟环境，这里我们需要选择一个 Python 解析器和创建一个<code>./venv</code>目录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv --system-site-packages -p python3 ./venv</span><br></pre></td></tr></table></figure></p>
<p>2.2 使用 source 命令激活虚拟环境。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ./venv/bin/activate  <span class="comment"># sh, bash, ksh, or zsh</span></span><br></pre></td></tr></table></figure></p>
<p>2.3 当虚拟环境被激活时，你的 shell 提示符前缀为<code>(venv)</code>。在虚拟环境中安装软件包，不会影响主机系统设置。<br>首先升级<code>pip</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip install --upgrade pip</span><br><span class="line"></span><br><span class="line">(venv) $ pip list  <span class="comment"># show packages installed within the virtual environment</span></span><br></pre></td></tr></table></figure></p>
<p>接着退出<code>virtualenv</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ deactivate  <span class="comment"># don't exit until you're done using TensorFlow</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-安装-TensorFlow-pip包"><a href="#3-安装-TensorFlow-pip包" class="headerlink" title="3. 安装 TensorFlow pip包"></a>3. 安装 TensorFlow pip包</h3><p>选择以下 TensorFlow 软件包的一个进行安装：</p>
<ul>
<li><code>tensorflow</code> —— 仅适用于CPU的当前版本（推荐初学者使用）</li>
<li><code>tensorflow-gpu</code> —— <a href="https://tensorflow.google.cn/install/gpu" target="_blank" rel="noopener">支持GPU</a>的当前版本（<code>Ubuntu</code> 和 <code>Windows</code>）</li>
<li><code>tf-nightly</code> —— 仅适用于CPU的每晚构建版本（不稳定）</li>
<li><code>tf-nightly-gpu</code> —— <a href="https://tensorflow.google.cn/install/gpu" target="_blank" rel="noopener">支持GPU</a>的每晚构建版本（不稳定，<code>Ubuntu</code> 和 <code>Windows</code>）</li>
</ul>
<blockquote>
<p>软件包的依赖项都会自动安装。这些列在<code>REQUIRED_PACKAGES</code>下的<a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/tools/pip_package/setup.py" target="_blank" rel="noopener"><code>setup.py</code></a>文件中。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip install --upgrade tensorflow</span><br></pre></td></tr></table></figure>
<p>验证是否安装成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python -c <span class="string">"import tensorflow as tf; tf.enable_eager_execution(); print(tf.reduce_sum(tf.random_normal([1000, 1000])))"</span></span><br></pre></td></tr></table></figure></p>
<p>如果输出结果，则说明 TensorFlow 安装成功！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://tensorflow.google.cn/install/pip?lang=python3" target="_blank" rel="noopener">https://tensorflow.google.cn/install/pip?lang=python3</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/TensorFlow/">TensorFlow</a><a href="/tags/Python/">Python</a><a href="/tags/机器学习/">机器学习</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/12/05/26-node-js文件流/"><span>26.node.js文件流</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/12/05/26-node-js文件流/" rel="bookmark">
        <time class="entry-date published" datetime="2018-12-05T06:06:03.000Z">
          2018-12-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="1-流的基本概念"><a href="#1-流的基本概念" class="headerlink" title="1.流的基本概念"></a>1.流的基本概念</h3><p>在一个应用程序中，流是一组有序的、有起点和终点的字节数据的传输手段。在应用程序中各种对象之间交换与传输数据时，总是先将该对象中所包含的数据转换为各种形式的流数据（即字节数据），再通过流的传输，到达目标对象后再将数据转换为该对象中可以使用的数据。</p>
<p>在 Node.js 中，我们可以使用实现了 <code>stream.Readable</code> 或 <code>stream.Writeable</code> 接口的对象来将对象数据读取为流数据，或者将流数据写入到对象中。它们都继承了 <code>EventEmitter</code> 类的实例对象，在读取数据或写入数据的过程中，将可能触发各种事件。</p>
<h5 id="表1-1-Node-js中的各种用于读取数据的对象"><a href="#表1-1-Node-js中的各种用于读取数据的对象" class="headerlink" title="表1-1 Node.js中的各种用于读取数据的对象"></a><center>表1-1 Node.js中的各种用于读取数据的对象</center></h5><table>
<thead>
<tr>
<th>对象</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fs.ReadStream</td>
<td>用于读取文件</td>
</tr>
<tr>
<td>http.IncomingMessage</td>
<td>代表客户端请求或服务器端响应</td>
</tr>
<tr>
<td>net.Socket</td>
<td>代表一个 socket 端口对象</td>
</tr>
<tr>
<td>child.stdout</td>
<td>用于创建子进程的标准输出流。如果子进程与父进程共享输入输出流，则子进程的标准输出流被废弃</td>
</tr>
<tr>
<td>child.stderr</td>
<td>用于创建子进程的标准错误输出流。如果子进程与父进程共享输入输出流，则子进程的标准错误输出流被废弃</td>
</tr>
<tr>
<td>process.stdin</td>
<td>用于创建进程的标准输入流</td>
</tr>
<tr>
<td>Gzip<br> Deflate<br> DeflateRaw</td>
<td>用于实现数据压缩</td>
</tr>
</tbody>
</table>
<h5 id="表1-2-读取数据的对象将会触发的事件"><a href="#表1-2-读取数据的对象将会触发的事件" class="headerlink" title="表1-2 读取数据的对象将会触发的事件"></a><center>表1-2 读取数据的对象将会触发的事件</center></h5><table>
<thead>
<tr>
<th>事件名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>readable</td>
<td>当可以从流中读出数据时触发。在大多数情况下，如果指定了 <code>readable</code> 事件的回调函数，将迫使操作系统将流数据首先读入操作系统缓存区中，然后再从操作系统缓存区中读出数据，当操作系统缓存区中对象被全部读出，且可以继续从流中读取数据时，将触发一个新的 <code>readable</code> 事件</td>
</tr>
<tr>
<td>data</td>
<td>当读取到来自于文件、客户端、服务器端等对象的新的数据时触发 <code>data</code> 事件。如果指定 <code>data</code> 事件的回调函数，将使用 <code>flowing</code> 模式来读取流数据（在 Node.js 中，可以使用 <code>flowing</code> 模式与 非 <code>flowing</code> 模式来读取数据。当使用 <code>flowing</code> 模式时，将使用操作系统的内部 I/O 机制来读取数据，，这允许你以最快速度读取数据。当使用非 <code>flowing</code> 模式时，你必须显式调用对象的 <code>read</code> 方法来读取数据）。参数值为存放了已读取到的数据的缓存区对象或一个字符串（当对流数据指定编码格式时）</td>
</tr>
<tr>
<td>end</td>
<td>当读取完所有数据时触发，该事件的触发意味着 <code>data</code> 事件将不再被触发</td>
</tr>
<tr>
<td>error</td>
<td>当读取数据过程中产生错误时触发</td>
</tr>
<tr>
<td>close</td>
<td>当用于读取流数据的对象被关闭时触发。并非所有用于读取流数据的对象都会触发该事件</td>
</tr>
</tbody>
</table>
<h5 id="表1-3-读取数据的对象的方法"><a href="#表1-3-读取数据的对象的方法" class="headerlink" title="表1-3 读取数据的对象的方法"></a><center>表1-3 读取数据的对象的方法</center></h5><table>
<thead>
<tr>
<th>事件名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>read</td>
<td>用于读取数据</td>
</tr>
<tr>
<td>setEncoding</td>
<td>用于指定用什么编码方式读取数据</td>
</tr>
<tr>
<td>pause</td>
<td>用于通知对象停止触发 <code>data</code> 事件</td>
</tr>
<tr>
<td>resume</td>
<td>用于通知对象恢复触发 <code>data</code> 事件</td>
</tr>
<tr>
<td>pipe</td>
<td>用于设置一个数据通道，然后取出所有流数据并将其输出到通道另一端所指向的目标对象中</td>
</tr>
<tr>
<td>unpipe</td>
<td>用于取消在 <code>pipe</code> 方法中设置的通道</td>
</tr>
<tr>
<td>unshift</td>
<td>当对流数据绑定了一个解析器时，可以使用 <code>unshift</code> 方法来取消该解析器的绑定，使流数据可以通过其他方式解析</td>
</tr>
</tbody>
</table>
<h5 id="表1-4-Node-js中的各种用于写入数据的对象"><a href="#表1-4-Node-js中的各种用于写入数据的对象" class="headerlink" title="表1-4 Node.js中的各种用于写入数据的对象"></a><center>表1-4 Node.js中的各种用于写入数据的对象</center></h5><table>
<thead>
<tr>
<th>对象</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fs.WriteStream</td>
<td>用于写入文件</td>
</tr>
<tr>
<td>http.ClientRequest</td>
<td>用于写入 HTTP 客户端请求数据</td>
</tr>
<tr>
<td>http.ServerResponse</td>
<td>用于写入 HTTP 服务端响应数据</td>
</tr>
<tr>
<td>net.Socket</td>
<td>用于读写 TCP 流或 UNIX 流，可被用户创建并作为一个客户端来使用，也可被 Node.js 脚本程序创建并通过服务器的 connection 事件来传递给用户</td>
</tr>
<tr>
<td>child.stdin</td>
<td>用于创建子进程的标准输入流。使用该对象的 close 方法将终止子进程。如果子进程与父进程共享输入输出流，则子进程的标准输入流数据被废弃</td>
</tr>
<tr>
<td>process.stdout</td>
<td>用于创建进程的标准输出流</td>
</tr>
<tr>
<td>process.stderr</td>
<td>用于创建进程的标准错误输出流</td>
</tr>
<tr>
<td>Gunzip<br> Inflate<br> InflateRaw</td>
<td>用于解压数据</td>
</tr>
</tbody>
</table>
<h5 id="表1-5-写入数据的对象将会触发的事件"><a href="#表1-5-写入数据的对象将会触发的事件" class="headerlink" title="表1-5 写入数据的对象将会触发的事件"></a><center>表1-5 写入数据的对象将会触发的事件</center></h5><table>
<thead>
<tr>
<th>事件名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>drain</td>
<td>当用于写入数据的 write 方法返回 false 之后触发，表示操作系统缓存区中的数据已全部输出到目标对象中，可以继续向操作系统缓存区写入数据</td>
</tr>
<tr>
<td>finish</td>
<td>当 end 方法被调用且数据被全部写入操作系统缓存区时触发</td>
</tr>
<tr>
<td>pipe</td>
<td>当用于读取数据的对象的 pipe 方法被调用时触发</td>
</tr>
<tr>
<td>unpipe</td>
<td>当用于读取数据的对象的 unpipe 方法被调用时触发</td>
</tr>
<tr>
<td>error</td>
<td>当写入数据的过程中产生错误时触发</td>
</tr>
</tbody>
</table>
<h5 id="表1-6-写入数据的对象的方法"><a href="#表1-6-写入数据的对象的方法" class="headerlink" title="表1-6 写入数据的对象的方法"></a><center>表1-6 写入数据的对象的方法</center></h5><table>
<thead>
<tr>
<th>事件名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>write</td>
<td>用于写入数据</td>
</tr>
<tr>
<td>end</td>
<td>当没有数据再被写入流中时调用该方法，这将迫使操作系统缓存区中的剩余数据被立即写入目标对象中。当该方法被调用后，将不能继续在目标对象中写入数据</td>
</tr>
</tbody>
</table>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/node-js/">node.js</a><a href="/tags/文件流/">文件流</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/21/25-Promise原理及实现/"><span>25.Promise原理及实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/21/25-Promise原理及实现/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-21T12:42:27.000Z">
          2018-11-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>上一篇文章 <a href="http://one-pieces.me/2018/11/14/24-Promises-A-%E8%A7%84%E8%8C%83/" target="_blank" rel="noopener">24.Promises/A+ 规范</a> 介绍了Promises/A+ 规范，我们来手动实现一个符合 Promises/A+ 规范的自己的Promise。</p>
<p>根据规范，Promise 共有三种状态 <code>pending</code>，<code>fulfilled</code>，<code>rejected</code>，我们使用 <code>state</code> 来表示 promise 当前的状态，使用 <code>value</code> 来表示当前<code>值</code>或<code>原因</code>。当然还有最重要的 <code>then</code> 方法。同时我们还需要一些辅助函数，比如 <code>isFunction</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.1</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.state = PENDING;</span><br><span class="line">  <span class="comment">// 值或原因</span></span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 2.2.1</span></span><br><span class="line">  <span class="keyword">if</span> (isFunction(onFulfilled) || isFunction(onRejected)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.onFulfilled = onFulfilled;</span><br><span class="line">    <span class="keyword">this</span>.onRejected = onRejected;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据2.2.7，</span></span><br><span class="line">  <span class="comment">// then必须返回一个 promise，但它还有其他的规则，</span></span><br><span class="line">  <span class="comment">// 这里我们先不管，直接返回当前 promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> func === <span class="string">'function'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，我们定义两个函数，可以将 promise 转换为 <code>fulfilled</code> 或 <code>rejected</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doResolve</span> (<span class="params">promise, value</span>) </span>&#123;</span><br><span class="line">  promise.state = FULFILLED;</span><br><span class="line">  promise.value = value;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isFunction(promise.onFulfilled)) &#123;</span><br><span class="line">    <span class="comment">// 2.2.4</span></span><br><span class="line">    <span class="comment">// 需要确保onFulfilled和onRejected的异步执行，</span></span><br><span class="line">    <span class="comment">// 是在调用then的事件轮训时间片之后，且调用栈为空。</span></span><br><span class="line">    <span class="comment">// 更多详情可看http://one-pieces.me/2018/11/14/24-Promises-A-%E8%A7%84%E8%8C%83/#3-%E6%B3%A8%E9%87%8A</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      promise.onFulfilled(promise.value);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doReject</span> (<span class="params">promise, reason</span>) </span>&#123;</span><br><span class="line">  promise.state = REJECTED;</span><br><span class="line">  promise.value = reason;</span><br><span class="line">  <span class="keyword">if</span> (isFunction(promise.onRejected)) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      promise.onRejected(promise.value);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们还需要一个 resolver，将刚才定义的 <code>doResolve</code> 和 <code>doReject</code> 暴露给 Promise 的构造函数。想想我们平时是怎么 new 一个 Promise的？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safelyResolveThen</span>(<span class="params">promise, then</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      doResolve(promise, value);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      doReject(promise, reason);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    doReject(promise, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后修改 Promise 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">resolver</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.state = PENDING;</span><br><span class="line">  <span class="comment">// 值或原因</span></span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">  safelyResolveThen(<span class="keyword">this</span>, resolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，Promise 最核心的功能已经实现。可以很容易地看出，这里 Promise 的底层实现使用了<code>回调（callback）</code></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/14/24-Promises-A-规范/"><span>24.Promises/A+ 规范</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/14/24-Promises-A-规范/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-14T09:13:13.000Z">
          2018-11-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>(原文 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promises/A+</a>)</p>
<p>一个具有互操作性的 JavaScript promises 的开源标准。</p>
<p>一个 promise 代表着异步操作的最终结果。与 promise 进行交互的主要方式是通过then方法，该方法注册回调来接收 promise 的最终值或 promise 无法完成（失败）的原因。</p>
<p>该规范详细说明了then方法的行为，它提供了一个可互操作的标准，使所有符合 Promises/A+ 规范的 promise 依据该标准来实现。因此，该规范应该被认为是非常稳定（stable）的。即使 Promises/A+ 组织偶尔会修改该规范，只是为了解决新发现的极端问题而加入一些比较小的向后兼容的更改，但只有经过仔细考虑，讨论和测试后，我们才会整合大的或向后不兼容的改动。</p>
<p>Promises/A+ 阐明了早期的 Promises/A 提案的行为条款，并将其扩展，使其覆盖到现实中的例子，且忽略了未确定和有问题的部分。</p>
<p>最后，该 Promises/A+ 规范的核心并不是规定如何新建（create），完成（fulfill），拒绝（reject） promises，而是专注于提供一个可互操作的then方法。相关规范的后续工作可能会涉及到这些主题。</p>
<h3 id="1-术语"><a href="#1-术语" class="headerlink" title="1. 术语"></a>1. 术语</h3><p>1.1 “promise” 是一个具有符合该规范规定行为的then方法的对象或函数</p>
<p>1.2 “thenable” 是一个定义了then方法的对象或函数。</p>
<p>1.3 <code>值</code>（”value”） 是任意合法的JavaScript的值（包括<code>undefined</code>，一个 thenable，或者一个 promise）。</p>
<p>1.4 <code>异常</code>（”exception”） 是 一个使用了<code>throw</code>语法抛出的值</p>
<p>1.5 <code>原因</code>（”reason”） 是一个表示为什么 promise 被拒绝的原因。</p>
<h3 id="2-要求"><a href="#2-要求" class="headerlink" title="2. 要求"></a>2. 要求</h3><h4 id="2-1-Promise状态"><a href="#2-1-Promise状态" class="headerlink" title="2.1 Promise状态"></a>2.1 Promise状态</h4><p>一个 Promise 必须处在以下三种状态中的一个：<code>pending</code>，<code>fulfilled</code>，<code>rejected</code>。</p>
<ul>
<li><p>2.1.1 当状态为<code>pending</code>时：  </p>
<ul>
<li>2.1.1.1 可以转换到<code>fulfilled</code>或者<code>rejected</code>。</li>
</ul>
</li>
<li><p>2.1.2 当状态为<code>fulfilled</code>时：</p>
<ul>
<li>2.1.2.1 不能转换为其它状态。</li>
<li>2.1.2.2 必须有一个不可修改的<code>值(value)</code>。</li>
</ul>
</li>
<li><p>2.1.3 当状态为<code>rejected</code>时：</p>
<ul>
<li>2.1.3.1 不能转换为其它状态。</li>
<li>2.1.3.2 必须有一个不可修改的<code>原因(reason)</code>。</li>
</ul>
</li>
</ul>
<p>上文的“不可修改”的含义是一旦创建就不能被修改（类似<code>===</code>），但并不意味着这个不可变性是深嵌套的。</p>
<h4 id="2-2-then方法"><a href="#2-2-then方法" class="headerlink" title="2.2 then方法"></a>2.2 <code>then</code>方法</h4><p>一个 promise 必须提供一个<code>then</code>方法去获取它当前或最终的<code>值</code>或<code>原因</code>。</p>
<p>一个 promise 的<code>then</code>方法接收两个参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>2.2.1 <code>onFulfilled</code>和<code>onRejected</code>都是可选参数：</p>
<ul>
<li>2.2.1.1 如果<code>onFulfilled</code>不是函数，则必须忽略它。</li>
<li>2.2.1.1 如果<code>onRejected</code>不是函数，则必须忽略它。</li>
</ul>
</li>
<li><p>2.2.2 如果<code>onFulfilled</code>是函数：</p>
<ul>
<li>2.2.2.1 则必须在 promise 状态转换为<code>fulfilled</code>之后调用它，且它的第一个参数为 promise 的<code>值</code>。</li>
<li>2.2.2.2 不能在 promise 状态转换为<code>fulfilled</code>之前调用它。</li>
<li>2.2.2.2 不能多次调用它。</li>
</ul>
</li>
<li><p>2.2.3 如果<code>onRejected</code>是函数：</p>
<ul>
<li>2.2.3.1 则必须在 promise 状态转换为<code>rejected</code>之后调用它，且它的第一个参数为 promise 的<code>原因</code>。</li>
<li>2.2.3.2 不能在 promise 状态转换为<code>rejected</code>之前调用它。</li>
<li>2.2.3.2 不能多次调用它。</li>
</ul>
</li>
<li><p>2.2.4 在执行上下文堆栈中仅包含平台代码<a href="#3-注释">[3.1]</a>之前，不能调用<code>onFulfilled</code>或<code>onRejected</code>。</p>
</li>
<li><p>2.2.5 <code>onFulfilled</code>和<code>onRejected</code>必须作为函数被调用（即没有<code>this</code>值）。<a href="#3-注释">[3.2]</a></p>
</li>
<li><p>2.2.6 同一个 promise 上的<code>then</code>可以被多次调用。</p>
<ul>
<li>2.2.6.1 如果/当 promise 为<code>fulfilled</code>时，所有相应的<code>onFulfilled</code>回调必须按其原本的调用顺序执行。</li>
<li>2.2.6.1 如果/当 promise 为<code>onRejected</code>时，所有相应的<code>onRejected</code>回调必须按其原本的调用顺序执行。</li>
</ul>
</li>
<li><p>2.2.7 <code>then</code>必须返回一个 promise。<a href="#3-注释">[3.3]</a></p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>
<ul>
<li>2.2.7.1 如果<code>onFulfilled</code>或<code>onRejected</code>返回一个<code>值</code>x，则运行 Promise 解析器（Promise Resolution Procedure）<code>[[Resolve]](promise2, x)</code>。</li>
<li>2.2.7.2 如果<code>onFulfilled</code>或<code>onRejected</code>返回一个<code>异常（exception）</code>e，则 promise2 必须以e为<code>原因</code>被拒绝。</li>
<li>2.2.7.3 如果<code>onFulfilled</code>不是函数且 promise1 为<code>fulfilled</code>，promise2 必须以与 promise1 相同的<code>值</code>被完成。</li>
<li>2.2.7.3 如果<code>onRejected</code>不是函数且 promise1 为<code>rejected</code>，promise2 必须以与 promise1 相同的<code>原因</code>被拒绝。</li>
</ul>
</li>
</ul>
<h4 id="2-3-Promise解析器"><a href="#2-3-Promise解析器" class="headerlink" title="2.3 Promise解析器"></a>2.3 Promise解析器</h4><p>Promise 解析器（promise resolution procedure）是一个抽象操作，它将 promise 和<code>值</code>作为输入，我们将其表示为<code>[[Resolve]](promise, x)</code>。如果<code>x</code>是<code>thenable</code>，它会使 promise 采用<code>x</code>的状态，假设<code>x</code>的行为至少有点像 promise。否则，它将以<code>x</code>为<code>值</code>完成 promise。</p>
<p>对<code>thenable</code>的这种处理使得 promise 具有互操作性，只要它们暴露出一个符合 Promises/A+ 规范的<code>then</code>方法。它还允许符合 Promises/A+ 规范的实现使用合理的<code>then</code>方法与“同化”不一致的实现。</p>
<p>为了运行<code>[[Resolve]](promise, x)</code>，需要实现以下几点：</p>
<ul>
<li>2.3.1 如果 promise 和<code>x</code>引用了同个对象，则用<code>TypeError</code>作为<code>原因</code>去拒绝 promise。</li>
<li><p>2.3.2 如果<code>x</code>是 promise，则采用它的状态：<a href="#3-注释">[3.4]</a></p>
<ul>
<li>2.3.2.1 如果<code>x</code>状态为<code>pending</code>，promise 必须保持<code>pending</code>直到<code>x</code>被完成或被拒绝。</li>
<li>2.3.2.2 如果/当<code>x</code>为<code>fulfilled</code>，用相同的<code>值</code>去完成 promise。</li>
<li>2.3.2.3 如果/当<code>x</code>为<code>rejected</code>，用相同的<code>原因</code>去拒绝 promise。</li>
</ul>
</li>
<li><p>2.3.3 否则，如果<code>x</code>是一个对象或函数，</p>
<ul>
<li>2.3.3.1 让<code>then</code>等于<code>x.then</code>。<a href="#3-注释">[3.5]</a></li>
<li>2.3.3.2 如果检测到属性<code>x.then</code>会导致抛出异常<code>e</code>，则用<code>e</code>作为<code>原因</code>去拒绝 promise。</li>
<li>2.3.3.3 如果<code>then</code>是函数（译者注，也就是<code>x</code>为<code>thenable</code>），则将<code>x</code>作为<code>this</code>调用它，第一个参数为<code>resolvePromise</code>，第二个参数为<code>rejectPromise</code>，其中：<ul>
<li>2.3.3.3.1 如果/当<code>resolvePromise</code>被调用且参数为<code>y</code>时，执行<code>[[Resolve]](promise, y)</code>。</li>
<li>2.3.3.3.2 如果/当<code>rejectPromise</code>被调用且参数为<code>r</code>时，则以<code>r</code>为<code>原因</code>拒绝 promise。</li>
<li>2.3.3.3.3 如果<code>resolvePromise</code>和<code>rejectPromise</code>都被调用，或者对同一个参数进行多次调用时，则处理第一次调用，且忽略后续调用。</li>
<li>2.3.3.3.4 如果调用<code>then</code>时抛出一个异常<code>e</code>，<ul>
<li>2.3.3.3.4.1 如果已调用<code>resolvePromise</code>或<code>rejectPromise</code>，请忽略它。</li>
<li>2.3.3.3.4.2 否则，以<code>e</code>作为<code>原因</code>拒绝 promise。</li>
</ul>
</li>
</ul>
</li>
<li>2.3.3.4 如果<code>then</code>不是函数，则以<code>x</code>作为<code>值</code>完成 promise。</li>
</ul>
</li>
<li>2.3.4 如果<code>x</code>不是一个对象或函数，则以<code>x</code>作为<code>值</code>完成 promise。</li>
</ul>
<p>如果使用了在<code>thenable</code>循环链（<code>thenable</code>的<code>then</code>是<code>thenable</code>）上的<code>thenable</code>去解决 promise，那么<code>[[Resolve]](promise, thenable)</code>的递归性质最终会导致<code>[[Resolve]](promise, thenable)</code>再次被调用，上述算法将导致无限递归。我们鼓励（但不是必需）对此类递归逻辑进行检测，如果有，则以一个信息性的<code>TypeError</code>作为<code>原因</code>去拒绝 promise。<a href="#3-注释">[3.6]</a></p>
<h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h3><ul>
<li><p>3.1 这里的<code>平台代码</code>特指执行引擎，运行环境和 promise 实现的代码。在实践中，这个要求确保了<code>onFulfilled</code>和<code>onRejected</code>的异步执行，是在调用<code>then</code>的事件轮训时间片之后，且调用栈为空。这可以使用诸如 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#timers" target="_blank" rel="noopener">setTimeout</a> 或 <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html#processingmodel" target="_blank" rel="noopener">setImmediate</a> 之类的<code>宏任务</code>机制，或者 <a href="https://dom.spec.whatwg.org/#interface-mutationobserver" target="_blank" rel="noopener">MutationObserver</a> 或 <a href="https://nodejs.org/api/process.html#process_process_nexttick_callback" target="_blank" rel="noopener">process.nextTick</a> 之类的<code>微任务</code>机制来实现。由于 promise 的实现代码被认为是平台代码，因此它本身可能包含一个任务调度队列或<code>trampoline（跳板）</code>来调用处理程序。</p>
</li>
<li><p>3.2 也就是说，在严格模式（<code>use strict</code>）下，<code>this</code>将是<code>undefined</code>；在松散模式（<code>sloppy mode</code>）下，<code>this</code>将会是全局对象。</p>
</li>
<li><p>3.3 如果具体实现满足所有要求，我们可以允许<code>promise2 === promise1</code>。每个具体实现都应该说明它是否可以支持<code>promise2 === promise1</code>，以及在什么条件下支持。</p>
</li>
<li><p>3.4 一般来说，如果它来自于当前的具体实现，那<code>x</code>可以被认为是一个真正的 promise。这个条款允许我们使用特定的实现手段，让我们可以去获取被认为符合规范（译者注，比如一个自行实现了<code>then</code>方法的对象）的 promises 的状态。</p>
</li>
<li><p>3.5 该步骤需先存储<code>x.then</code>的引用，后续测试和调用的都是该引用，这样可以避免多次访问<code>x.then</code>属性。这些预防措施对于保证可访问属性的一致性非常重要。可访问属性的值可能会在检索之间发生变化。</p>
</li>
<li><p>3.6 该实现不应该对<code>thenable</code>链的深度设置某个限制值，假设超过这个限制值之后会发生无限递归。只有真正的循环才会引起一个<code>TypeError</code>错误；如果是不同的<code>thenable</code>组成一个无穷的调用链，那么一直递归其实是正确的行为。</p>
</li>
</ul>
<p>在法律允许的范围内，Promises/A+ 组织已放弃 Promises/A+ Promise 规范的所有版权，以及相关或相近的权利。该声明发表于：美国。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Promise/">Promise</a><a href="/tags/规范/">规范</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/09/23-客户端JavaScript执行的时间线/"><span>23.浏览器JavaScript执行的时间线</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/09/23-客户端JavaScript执行的时间线/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-09T07:29:40.000Z">
          2018-11-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道浏览器的渲染线程和脚本线程是互斥的，JavaScript会阻塞浏览器HTML解析器，这也是为什么长时间的脚本运行可能会导致页面失去响应。因此，我们通常会把<code>&lt;script&gt;</code>放在<code>&lt;/body&gt;</code>之前，来保证非脚本的其他一切元素能尽快地得到加载和解析。<br>然而，我们可以通过设置<code>&lt;scirpt&gt;</code>的<code>async</code>和<code>defer</code>来改变<code>&lt;script&gt;</code>的加载和执行顺序。在说这具体是怎样之前,我们先介绍一下浏览器JavaScript执行的时间线。</p>
<h2 id="JavaScript的执行"><a href="#JavaScript的执行" class="headerlink" title="JavaScript的执行"></a>JavaScript的执行</h2><ol>
<li><p>浏览器创建<code>Document</code>对象，并且开始解析Web页面，解析HTML元素和它们的文本内容后，会添加Element对象和Text节点到文档中。在这个阶段document.readystate属性的值是<code>loading</code>。</p>
</li>
<li><p>当HTML解析器遇到没有<code>async</code>和<code>defer</code>属性的<code>&lt;script&gt;</code>元素时，它把这些元素添加到文档中，然后执行行内或者外部脚步。这些脚本会同步执行，并且在脚本下载（如果需要）和执行时，HTML解析器会暂停。这样脚本就可以用<code>document.write()</code>来把文本插入到输入流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单定义函数和注册后面使用的注册事件处理程序，但它们可以遍历和操作文档树，因为在它们执行时已经存在了。这样，同步脚本可以看到它自己的<code>&lt;script&gt;</code>元素和它们之前的文档内容。</p>
</li>
<li><p>当解析器遇到设置了<code>async</code>属性的<code>&lt;script&gt;</code>元素时，它开始下载脚本文本，并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器没有停下来等它下载。异步脚本禁止使用<code>document.write()</code>方法。它们可以看到自己的<code>&lt;script&gt;</code>元素和它之前的所有文档元素，并且可能或干脆不访问其他的文档内容。</p>
</li>
<li><p>当文档完成解析，<code>document.readyState</code>属性变成<code>interactive</code>。</p>
</li>
<li><p>所有有<code>defer</code>属性的脚本，会按它们在文档里的出现顺序执行。异步脚本可能也会在这个时间执行。延迟脚本能访问完整的文档树，禁止使用<code>document.write()</code>方法。</p>
</li>
<li><p>浏览器在<code>Document</code>对象上触发<code>DOMContentLoaded</code>事件。这标志着程序执行从同步脚本执行阶段转换到了异步事件驱动阶段。但要注意，这时可能还有异步脚本没有执行完成。</p>
</li>
<li><p>这时，文档已经完全解析完成，但是浏览器可能还在等待其他内容载入，比如图片。当所有这些内容完成载入时，并且所有异步脚本完成载入和执行，<code>document.readyState</code>属性改变为<code>complete</code>，浏览器触发<code>Window</code>对象上的<code>load</code>事件。</p>
</li>
<li><p>从此刻起，会调用异步事件，以异步响应用户输入事件、网络事件、计时器过期等。</p>
</li>
</ol>
<p>需要注意的是，这是一条理想的时间线，每种浏览器的具体细节实现可能不一样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面的分析，我们可以总结一下。当浏览器遇到<code>&lt;script&gt;</code>脚本时：</p>
<ol>
<li><p>同步脚本<code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br> 没有<code>defer</code>或<code>async</code>，浏览器会立即加载并执行指定的脚本，<code>立即</code>指的是在渲染该<code>&lt;script&gt;</code>标签之下的文档元素之前，也就是说文档解析器会暂停，浏览器读到就加载并执行。</p>
</li>
<li><p>异步脚本<code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br> 有<code>async</code>，加载和渲染后续文档元素的过程和<code>script.js</code>的加载与执行并行进行（异步）。</p>
</li>
<li><p>延迟脚本<code>&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br> 有<code>defer</code>，加载后续文档元素的过程和<code>script.js</code>的加载并行进行（异步），但是<code>script.js</code>的执行要在所有元素解析完成（<code>document.readyState</code>属性变成<code>interactive</code>）之后，<code>DOMContentLoaded</code>事件触发之前完成。</p>
</li>
</ol>
<p>最后用一张图来总结：<br><img src="../images/23/1.png" alt="image"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/JavaScript/">JavaScript</a><a href="/tags/浏览器/">浏览器</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/08/23-使用原生JS实现dialog组件/"><span>(WIP)23.使用原生JS实现dialog组件</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/08/23-使用原生JS实现dialog组件/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-08T08:51:45.000Z">
          2018-11-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当时觉得这个蛮简单的，只要写好html、样式，然后append进document.body就行了。但真正写起来时才发现没那么简单。比如原生的appendChild需要参数为Node，而你现在是需要把HTML的字符串转化为Node。这要怎么做呢？</p>
<h2 id="String转化为DOM"><a href="#String转化为DOM" class="headerlink" title="String转化为DOM"></a>String转化为DOM</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/WIP/">WIP</a><a href="/tags/JavaScript/">JavaScript</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/08/22-Webpack提示Invalid-Host-Header/"><span>22-Webpack提示Invalid Host Header</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/08/22-Webpack提示Invalid-Host-Header/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-08T07:49:09.000Z">
          2018-11-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>用<a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener"><code>vue-cli 3</code></a>新建项目，将自定义域名映射到localhost，这时用自定义域名访问项目，webpack-dev-server返回了Invalid Host Header，而使用localhost或127.0.0.1则没报错。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>网上查了一些资料，发现这是因为webpack-dev-server在<a href="https://github.com/webpack/webpack-dev-server/releases/tag/v2.4.3" target="_blank" rel="noopener"><code>2.4.3</code></a>和<a href="https://github.com/webpack/webpack-dev-server/releases/tag/v1.16.4" target="_blank" rel="noopener"><code>1.16.4</code></a>这两个版本增加了security fix。这个fix增加了对<code>Host</code> header 的检验，来防止恶意网站访问你的<code>assets</code>。同时<code>webpack-dev-middleware</code>的<code>1.10.2</code>也增加了这个修改。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>考虑到这个fix可能会break项目启动，webpack-dev-server提供了几个解决方案</p>
<ul>
<li>新增<code>disableHostCheck</code>参数，为<code>true</code>时host check失效</li>
<li>执行webpack-dev-server时手动添加<code>--public</code>参数，值为授权的host</li>
</ul>
<p>在后续的版本里，webpack-dev-server也增加了相关的一些参数，比如<code>allowedHosts</code>(<a href="https://github.com/webpack/webpack-dev-server/releases/tag/v2.5.0" target="_blank" rel="noopener"><code>2.5.0</code></a>)。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://tonghuashuo.github.io/blog/webpack-dev-server-invalid-host-header.html" target="_blank" rel="noopener">解决 Webpack “Invalid Host Header”</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/webpack/">webpack</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/25/21-docker-jenkins自动部署/"><span>21.docker+jenkins自动部署前端代码</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/25/21-docker-jenkins自动部署/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-25T15:12:50.000Z">
          2018-09-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>服务器为腾讯云Ubuntu</p>
</blockquote>
<h3 id="一、安装Docker"><a href="#一、安装Docker" class="headerlink" title="一、安装Docker"></a>一、安装Docker</h3><ol>
<li><p>更新<code>apt</code>包</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装最新版本的Docker</p>
<p> 中文版教程： <a href="https://cloud.tencent.com/developer/article/1167995" target="_blank" rel="noopener">如何在Ubuntu上安装使用Docker</a></p>
<p> 不过最好还是看英文版：<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-using-the-repository" target="_blank" rel="noopener">install-using-the-repository</a></p>
<p> 或者使用官方Ubuntu存储库中提供的Docker安装包，但是可能不是最新的版本。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用内置安装</span></span><br><span class="line">$ sudo apt-get install docker.io</span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">$ sudo apt-get purge docker.io</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="二、安装Jenkins"><a href="#二、安装Jenkins" class="headerlink" title="二、安装Jenkins"></a>二、安装Jenkins</h3><p>使用docker安装Jenkins非常方便，只需要执行下面命令即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name devops-jenkins --user=root -p 8080:8080 -p 50000:50000 -v /opt/data/jenkins_home:/var/jenkins_home -d jenkins/jenkins:lts</span><br></pre></td></tr></table></figure></p>
<p>更多定制参数可以参考 <a href="https://github.com/jenkinsci/docker" target="_blank" rel="noopener">https://github.com/jenkinsci/docker</a></p>
<h3 id="三、配置Jenkins"><a href="#三、配置Jenkins" class="headerlink" title="三、配置Jenkins"></a>三、配置Jenkins</h3><p>启动Jenkins之后，在浏览器输入http://部署jenkins主机IP:端口 (8080)<br><img src="../images/21/1.png" alt="image"></p>
<p>根据提示，从输入administrator password 或者可以通过启动日志<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs devops-jenkins</span><br></pre></td></tr></table></figure></p>
<p>查看这个password<br><img src="../images/21/2.png" alt="image"></p>
<p>选择安装插件方式，这里默认第一个。<br><!-- ![image](../images/21/3.png) --></p>
<p>进入插件安装界面，连网等待插件安装。</p>
<p>安装完插件后，进入创建管理员界面。<br><img src="../images/21/5.png" alt="image"></p>
<p>输入管理员信息后，点击Continue as admin。</p>
<p><img src="../images/21/6.png" alt="image"><br>保存Jenkins URL后Jenkins就安装完毕了。</p>
<h3 id="四、自动化流程"><a href="#四、自动化流程" class="headerlink" title="四、自动化流程"></a>四、自动化流程</h3><p>在正式使用Jenkins前，我们先来看一下自动部署的流程，具体如下：</p>
<ul>
<li>编写修改代码，并提交代码到代码仓库（git）</li>
<li>Jenkins自动检测到仓库代码更新了，从仓库拉去最新代码</li>
<li>Jenkins自动编译</li>
<li></li>
</ul>
<p>Jenkins之所以流行，是因为它的高灵活性和高易用性。这得益于它的插件机制，只需安装对应功能的插件，即可使它适应各种业务场景。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/23/20-使用wafer2-quickstart-nodejs-master小程序模板本地开发踩坑指南/"><span>20.使用wafer2-quickstart-nodejs-master小程序模板本地开发踩坑指南</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/23/20-使用wafer2-quickstart-nodejs-master小程序模板本地开发踩坑指南/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-23T14:31:07.000Z">
          2018-09-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="使用wafer2-quickstart-nodejs-master小程序模板本地开发踩坑指南"><a href="#使用wafer2-quickstart-nodejs-master小程序模板本地开发踩坑指南" class="headerlink" title="使用wafer2-quickstart-nodejs-master小程序模板本地开发踩坑指南"></a>使用wafer2-quickstart-nodejs-master小程序模板本地开发踩坑指南</h2><h4 id="一、本地调试获取用户失败"><a href="#一、本地调试获取用户失败" class="headerlink" title="一、本地调试获取用户失败"></a>一、本地调试获取用户失败</h4><p>在使用微信官方提供的 <a href="https://github.com/tencentyun/wafer2-quickstart-nodejs" target="_blank" rel="noopener">wafer2-quickstart-nodejs-master</a> 模板开发小程序时，除了可以连接腾讯云提供的开发环境，还可以直接在本地起服务进行调试。具体操作可参考<a href="https://github.com/tencentyun/wafer2-startup/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98#%E6%9C%AC%E5%9C%B0%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">本地如何搭建开发环境</a>。</p>
<p>但按照文档上的步骤操作，会报“ERR_REQUEST_PARAM”的错误。报这个错误的原因是，代码默认使用了腾讯云代理登录小程序。</p>
<p>打开<code>server/config.js</code>，将<code>useQcloudLogin</code>选项修改为false，同时还需要填上小程序的<code>appSecret</code>。因为<code>useQcloudLogin</code>为<code>true</code>时，<code>SDK</code>会通过与小程序关联的腾讯云账号获取到<code>appSecret</code>，授权通过后，再获取用户信息。否则为<code>false</code>时，则需要填写<code>appSecret</code>。</p>
<p>这样修改后，再次请求，就能获取到用户信息了。</p>
<h4 id="二、第一次获取用户信息"><a href="#二、第一次获取用户信息" class="headerlink" title="二、第一次获取用户信息"></a>二、第一次获取用户信息</h4><p>在模板中，<code>wafer2-client-sdk</code>封装了一下方法让我们使用。比如我们可以使用<code>request</code>发送请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qcloud = <span class="built_in">require</span>(<span class="string">'../vendor/wafer2-client-sdk/index'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 请求A</span></span><br><span class="line">qcloud.request(&#123;</span><br><span class="line">    url,</span><br><span class="line">   	data,</span><br><span class="line">    method,</span><br><span class="line">    login: <span class="literal">false</span>,</span><br><span class="line">    success(result) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    fail(error) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过参数<code>login</code>可以控制发送该请求<code>A</code>之前，是否先发送登录请求。如果请求<code>A</code>需要用户信息，则<code>login</code>需为<code>true</code>，否则后端的ctx.state.$wxInfo是没有用户信息的。但是在用户第一次登录之前（<code>cSessioninfo</code>表里没有该用户数据），<code>qcloud.request({ login: true })</code>会报错，返回<code>Cannot read property &#39;user_info&#39; of undefined</code>错误。</p>
<p>这是因为<code>qcloud.request</code>只使用了<code>loginWithCode</code>来登录。这个方法会在<code>Header</code>加上<code>X-WX-Code</code>（其实就是<code>cSessioninfo</code>表里的<code>skey</code>）。后端通过这个code去获取对应用户的信息。但因为表里根本没有这个用户的记录，所以报了上面的错误。</p>
<p>要怎么解决这个问题？其实模板中有类似的调用。打开<code>client/page/pages/index/index.js</code>，答案就在<code>bindGetUserInfo</code>里。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 先获取session</span></span><br><span class="line"><span class="keyword">const</span> session = qcloud.Session.get()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 如果session不为空，则说明用户已经登录过，即数据库里有该用户记录，则使用qcloud.loginWithCode</span></span><br><span class="line"><span class="comment">// 2. 如果session为空，则说明用户第一次登录，则调用qcloud.login，将用户信息写入数据库</span></span><br><span class="line"><span class="keyword">if</span> (session) &#123;</span><br><span class="line">    <span class="comment">// 第二次登录</span></span><br><span class="line">    <span class="comment">// 或者本地已经有登录态</span></span><br><span class="line">    <span class="comment">// 可使用本函数更新登录态</span></span><br><span class="line">    qcloud.loginWithCode(&#123;</span><br><span class="line">        success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 首次登录</span></span><br><span class="line">    qcloud.login(&#123;</span><br><span class="line">        success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>qcloud.login</code>会在<code>Header</code>增加三个字段，<code>X-WX-Code</code>、<code>X-WX-Encrypted-Data</code>、<code>X-WX-IV</code>，然后后端会在表里插入该用户的信息。</p>
<p>所以我们需要将这段逻辑加到<code>qcloud.request</code>里。<code>qcloud.request</code>里有个<code>doRequestWithLogin</code>方法，是发送登录逻辑的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录后再请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doRequestWithLogin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    loginLib.loginWithCode(&#123; <span class="attr">success</span>: doRequest, <span class="attr">fail</span>: callFail &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将其修改为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录后再请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doRequestWithLogin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> session = Session.get()</span><br><span class="line">    <span class="keyword">if</span> (session) &#123;</span><br><span class="line">        loginLib.loginWithCode(&#123; <span class="attr">success</span>: doRequest, <span class="attr">fail</span>: callFail &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        loginLib.login(&#123; <span class="attr">success</span>: doRequest, <span class="attr">fail</span>: callFail &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Done！大功告成，再次发送请求成功！</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/微信小程序/">微信小程序</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 Xiaolong Lin
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>